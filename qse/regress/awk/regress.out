--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-001.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR 275
Canada 25
China 1032
USA 237
Brazil 134
India 746
Mexico 78
France 55
Japan 120
Germany 61
England 56
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-002.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
   COUNTRY   AREA   POP    CONTINENT

      USSR   8649   275    Asia
    Canada   3852    25    North America
     China   3705  1032    Asia
       USA   3615   237    North America
    Brazil   3286   134    South America
     India   1267   746    Asia
    Mexico    762    78    North America
    France    211    55    Europe
     Japan    144   120    Asia
   Germany     96    61    Europe
   England     94    56    Europe

     TOTAL  25681  2819
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-003.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
India	1267	746	Asia
Japan	144	120	Asia
Germany	96	61	Europe
England	94	56	Europe
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-004.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR	8649	275	Asia
USA	3615	237	North America
Mexico	762	78	North America
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-005.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Canada	3852	25	North America
Brazil	3286	134	South America
Mexico	762	78	North America
England	94	56	Europe
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-006.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-007.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR	8649	275	Asia
China	3705	1032	Asia
India	1267	746	Asia
Japan	144	120	Asia
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-008.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR	8649	275	Asia
China	3705	1032	Asia
India	1267	746	Asia
Japan	144	120	Asia
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-009.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Canada	3852	25	North America
USA	3615	237	North America
Brazil	3286	134	South America
Mexico	762	78	North America
France	211	55	Europe
Germany	96	61	Europe
England	94	56	Europe
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-010.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR	8649	275	Asia
China	3705	1032	Asia
India	1267	746	Asia
Japan	144	120	Asia
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-011.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-012.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
China	3705	1032	Asia
India	1267	746	Asia
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-013.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR	8649	275	Asia
China	3705	1032	Asia
India	1267	746	Asia
France	211	55	Europe
Japan	144	120	Asia
Germany	96	61	Europe
England	94	56	Europe
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-014.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR	8649	275	Asia
China	3705	1032	Asia
India	1267	746	Asia
France	211	55	Europe
Japan	144	120	Asia
Germany	96	61	Europe
England	94	56	Europe
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-015.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR	8649	275	Asia
China	3705	1032	Asia
India	1267	746	Asia
France	211	55	Europe
Japan	144	120	Asia
Germany	96	61	Europe
England	94	56	Europe
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-016.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR	8649	275	Asia
China	3705	1032	Asia
India	1267	746	Asia
France	211	55	Europe
Japan	144	120	Asia
Germany	96	61	Europe
England	94	56	Europe
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-017.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Canada	3852	25	North America
China	3705	1032	Asia
USA	3615	237	North America
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-018.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-019.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk/cou.dat: USSR	8649	275	Asia
/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk/cou.dat: Canada	3852	25	North America
/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk/cou.dat: China	3705	1032	Asia
/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk/cou.dat: USA	3615	237	North America
/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk/cou.dat: Brazil	3286	134	South America
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-020.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk/cou.dat: USSR	8649	275	Asia
/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk/cou.dat: Canada	3852	25	North America
/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk/cou.dat: China	3705	1032	Asia
/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk/cou.dat: USA	3615	237	North America
/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk/cou.dat: Brazil	3286	134	South America
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-021.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR 8649000
China 3705000
India 1267000
Japan 144000
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-022.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR	8649	275	Asia
Canada	3852	25	NA
China	3705	1032	Asia
USA	3615	237	NA
Brazil	3286	134	SA
India	1267	746	Asia
Mexico	762	78	NA
France	211	55	Europe
Japan	144	120	Asia
Germany	96	61	Europe
England	94	56	Europe
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-023.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
USSR	8649	275	Asia	31.7956
Canada	3852	25	North America	6.49013
China	3705	1032	Asia	278.543
USA	3615	237	North America	65.5602
Brazil	3286	134	South America	40.7791
India	1267	746	Asia	588.792
Mexico	762	78	North America	102.362
France	211	55	Europe	260.664
Japan	144	120	Asia	833.333
Germany	96	61	Europe	635.417
England	94	56	Europe	595.745
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-024.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Total population of the 4 Asian countries is 2173 million.
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-025.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Asian population is 2173 million.
European population is 172 million.
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-026.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Asia 2173
Europe 172
North America 340
South America 134
--------------------------------------------------------------------------------
[CMD]  qseawk   -f cou-027.awk cou.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
           Asia	  2173
  North America	   340
         Europe	   172
  South America	   134
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-001.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Kathy 40
Mark 100
Mary 121
Susie 76.5
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-002.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Beth
Dan
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-003.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
3 Beth 0
3 Dan 0
3 Kathy 10
3 Mark 20
3 Mary 22
3 Susie 18
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-004.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
1 Beth	4.00	0
2 Dan	3.74	0
3 Kathy	4.00	10
4 Mark	5.00	20
5 Mary	5.50	22
6 Susie	4.25	18
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-005.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
total pay for Beth is 0
total pay for Dan is 0
total pay for Kathy is 40
total pay for Mark is 100
total pay for Mary is 121
total pay for Susie is 76.5
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-006.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
total pay for Beth is $0.00
total pay for Dan is $0.00
total pay for Kathy is $40.00
total pay for Mark is $100.00
total pay for Mary is $121.00
total pay for Susie is $76.50
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-007.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Beth     $  0.00
Dan      $  0.00
Kathy    $ 40.00
Mark     $100.00
Mary     $121.00
Susie    $ 76.50
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-008.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Mark	5.00	20
Mary	5.50	22
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-009.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
$100.00 for Mark
$121.00 for Mary
$76.50 for Susie
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-010.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Susie	4.25	18
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-011.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Susie	4.25	18
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-012.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Beth	4.00	0
Kathy	4.00	10
Mark	5.00	20
Mary	5.50	22
Susie	4.25	18
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-013.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Beth	4.00	0
Kathy	4.00	10
Mark	5.00	20
Mark	5.00	20
Mary	5.50	22
Mary	5.50	22
Susie	4.25	18
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-014.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Beth	4.00	0
Kathy	4.00	10
Mark	5.00	20
Mary	5.50	22
Susie	4.25	18
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-015.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-016.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
NAME    RATE    HOURS

Beth	4.00	0
Dan	3.74	0
Kathy	4.00	10
Mark	5.00	20
Mary	5.50	22
Susie	4.25	18
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-017.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
3 employees worked more than 15 hours
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-018.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
6 employees
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-019.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
6 employees
total pay is 337.5
average pay is 56.25
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-020.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
highest hourly rage: 5.50 for Mary
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-021.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Beth Dan Kathy Mark Mary Susie 
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-022.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Susie	4.25	18
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-023.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Beth 4
Dan 3
Kathy 5
Mark 4
Mary 4
Susie 5
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-024.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
6 lines, 18 words, 77 characters
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-025.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
no employees are paid more than $6/hour
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-026.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Susie	4.25	18
Mary	5.50	22
Mark	5.00	20
Kathy	4.00	10
Dan	3.74	0
Beth	4.00	0
--------------------------------------------------------------------------------
[CMD]  qseawk   -f emp-027.awk emp.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Susie	4.25	18
Mary	5.50	22
Mark	5.00	20
Kathy	4.00	10
Dan	3.74	0
Beth	4.00	0
--------------------------------------------------------------------------------
[CMD]  qseawk   -f adr-001.awk adr.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
James Brown 012-345-678
Richie Ren 02-3473-9192
Toh WeeKung 9102-1203
--------------------------------------------------------------------------------
[CMD]  qseawk   -f adr-002.awk adr.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
James Brown Somewhere over the rainbow 012-345-678
Toh WeeKung Singapore 9102-1203
--------------------------------------------------------------------------------
[CMD]  qseawk   -f unr-001.awk unr.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Beth	4	0
Dan	3.74	0
0	4.00	10
Mark	5.00	20
Mary	5.5	22
Susie	4.25	18
--------------------------------------------------------------------------------
[CMD]  qseawk  --strictnaming=off --newline=on -d- -f lang-001.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function f (__p0)
{
	print __p0;
}

BEGIN {
	f("hello");
}

hello
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-002.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function f (__p0)
{
	print __p0;
	f("my hello");
}

BEGIN {
	f(10);
}

10
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
my hello
ERROR: CODE 16 LINE 6 COLUMN 1 - block nested too deeply
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-003.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function fn (__p0)
{
	__p0 = 20;
}

BEGIN {
	f = 50;
	fn(100);
	print f;
}

50
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-004.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 43 LINE 3 COLUMN 9 - function 'a' redefined
--------------------------------------------------------------------------------
[CMD]  qseawk  --implicit=off --explicit=on --newline=on -d- -f lang-005.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function a (__p0)
{
	print __p0;
}

BEGIN {
	local __l0, __l1;
	{
		__l0 = 50;
		{
			__l1 = 30;
			print __l1;
		}
		print __l0;
	}
	a(100);
}

30
50
100
--------------------------------------------------------------------------------
[CMD]  qseawk  --implicit=off --explicit=on --newline=on -d- -f lang-006.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 44 LINE 5 COLUMN 10 - global variable 'a' redefined
--------------------------------------------------------------------------------
[CMD]  qseawk  --implicit=on --explicit=on --newline=on -d- -f lang-007.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
global __g19;

function fn ()
{
	a = 20;
	return a;
}

BEGIN {
	__g19 = 30;
	print fn();
	print __g19;
}

20
30
--------------------------------------------------------------------------------
[CMD]  qseawk  --implicit=off --explicit=on --newline=on -d- -f lang-008.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
global x;

BEGIN {
	local __l0, __l1;
	x = 1;
	{
		__l0 = 2;
		{
			__l1 = 3;
			print __l1;
		}
		print __l0;
	}
	print x;
}

3
2
1
--------------------------------------------------------------------------------
[CMD]  qseawk  --implicit=off --explicit=on --newline=on --strictnaming=off -d- -f lang-009.awk lang-009.awk </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function a (__p0)
{
	print __p0;
}

BEGIN {
	local __l0;
	__l0 = 20;
}

END {
	a(1000);
}
1000
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-010.awk this is just a test </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	print "ARGC=",ARGC;
	for (i in ARGV)
	{
		print (("ARGV["   i)   "]"),ARGV[i];
	}
	print "----------------------";
	print "ARGC=",ARGC;
	split("111 22 333 555 666 777",ARGV);
	for (i in ARGV)
	{
		print (("ARGV["   i)   "]"),ARGV[i];
	}
	if ((ARGC >= 0))
		printf ("ARGC [%++#10.10i] is positive\n",10);
	if ((ARGC >= 0))
		printf ("ARGC [%++#10.10f] is positive\n",10);
	if ((ARGC >= 0))
		printf ("ARGC [%++#10.10E] is positive\n",10124.1123);
	if ((ARGC >= 0))
		printf ("ARGC [%++#10.10G] is positive\n",10124.1123);
	if ((ARGC >= 0))
		printf ("ARGC [%++#10.10g] is positive\n",10124.1123);
	if ((ARGC >= 0))
		printf ("ARGC [%++#10.10f] is positive\n",10124.1123);
	printf ("[%d], [%f], [%s]\n",10124.1123,10124.1123,10124.1123);
	printf ("[%-10c] [% 0*.*d]\n",65,45,48,-1);
	print sprintf("abc%d %*.*d %c %s %c",10,20,30,40,"good","good",75.34);
}

ARGC= 6
ARGV[0] qseawk
ARGV[1] this
ARGV[2] is
ARGV[3] just
ARGV[4] a
ARGV[5] test
----------------------
ARGC= 6
ARGV[1] 111
ARGV[2] 22
ARGV[3] 333
ARGV[4] 555
ARGV[5] 666
ARGV[6] 777
ARGC [+0000000010] is positive
ARGC [+10.0000000000] is positive
ARGC [+1.0124112300E+04] is positive
ARGC [+10124.11230] is positive
ARGC [+10124.11230] is positive
ARGC [+10124.1123000000] is positive
[10124], [10124.112300], [10124.1]
[A         ] [-000000000000000000000000000000000000000000000001]
abc10 000000000000000000000000000040 g good K
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-011.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	a[1,2,3] = 20;
	a[4,5,6] = 30;
	for (i in a)
	{
		n = split(i,k,SUBSEP);
		for (j = 1; (j <= n); (j)++)
		{
			print k[j];
		}
		print "-------------------";
	}
	if (((1,2,3) in a))
	{
		print ("(1,2,3) in a ==> "   a[1,2,3]);
	}
	else
	{
		print "(1,2,3) not in a";
	}
	if (((4,5) in a))
	{
		print ("(4,5) in a ==> "   a[4,5]);
	}
	else
	{
		print "(4,5) not in a";
	}
}

4
5
6
-------------------
1
2
3
-------------------
(1,2,3) in a ==> 20
(4,5) not in a
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-012.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	OFS = "\t\t";
	print "1==1 :",(1 == 1);
	print "1==0 :",(1 == 0);
	print "1.0==1 :",(1.0 == 1);
	print "1.1==1 :",(1.1 == 1);
	print "1.0!=1 :",(1.0 != 1);
	print "1.1!=1 :",(1.1 != 1);
	print "\"abc\" == \"abc\"",("abc" == "abc");
	print "\"abc\" != \"abc\"",("abc" != "abc");
	print "--------------------------";
	print "a == \"\" :",(a == "");
	print "a >= \"\" :",(a >= "");
	print "a <= \"\" :",(a <= "");
	print "a >  \"\" :",(a > "");
	print "a <  \"\" :",(a < "");
	print "--------------------------";
	print "a == \" \" :",(a == " ");
	print "a >= \" \" :",(a >= " ");
	print "a <= \" \" :",(a <= " ");
	print "a >  \" \" :",(a > " ");
	print "a <  \" \" :",(a < " ");
	print "--------------------------";
	print "\"\" == a :",("" == a);
	print "\"\" >= a:",("" >= a);
	print "\"\" <= a:",("" <= a);
	print "\"\" >  a:",("" > a);
	print "\"\" <  a:",("" < a);
	print "--------------------------";
	print "\" \" == a :",(" " == a);
	print "\" \" >= a:",(" " >= a);
	print "\" \" <= a:",(" " <= a);
	print "\" \" >  a:",(" " > a);
	print "\" \" <  a:",(" " < a);
	print "--------------------------";
	print "10 == \"10\"",(10 == "10");
	print "10 != \"10\"",(10 != "10");
	print "10 >= \"10\"",(10 >= "10");
	print "10 <= \"10\"",(10 <= "10");
	print "10 >  \"10\"",(10 > "10");
	print "10 <  \"10\"",(10 < "10");
	print "--------------------------";
	print "10 == \"11\"",(10 == "11");
	print "10 != \"11\"",(10 != "11");
	print "10 >= \"11\"",(10 >= "11");
	print "10 <= \"11\"",(10 <= "11");
	print "10 >  \"11\"",(10 > "11");
	print "10 <  \"11\"",(10 < "11");
	print "--------------------------";
	print "11 == \"10\"",(11 == "10");
	print "11 != \"10\"",(11 != "10");
	print "11 >= \"10\"",(11 >= "10");
	print "11 <= \"10\"",(11 <= "10");
	print "11 >  \"10\"",(11 > "10");
	print "11 <  \"10\"",(11 < "10");
	print "--------------------------";
	print "010 == \"8\"",(010 == "8");
	print "010 != \"8\"",(010 != "8");
	print "010 >= \"8\"",(010 >= "8");
	print "010 <= \"8\"",(010 <= "8");
	print "010 >  \"8\"",(010 > "8");
	print "010 <  \"8\"",(010 < "8");
	print "--------------------------";
	print "10 == \"10.0\"",(10 == "10.0");
	print "10 != \"10.0\"",(10 != "10.0");
	print "10 >= \"10.0\"",(10 >= "10.0");
	print "10 <= \"10.0\"",(10 <= "10.0");
	print "10 >  \"10.0\"",(10 > "10.0");
	print "10 <  \"10.0\"",(10 < "10.0");
	print "--------------------------";
	print "10.0 == \"10\"",(10.0 == "10");
	print "10.0 != \"10\"",(10.0 != "10");
	print "10.0 >= \"10\"",(10.0 >= "10");
	print "10.0 <= \"10\"",(10.0 <= "10");
	print "10.0 >  \"10\"",(10.0 > "10");
	print "10.0 <  \"10\"",(10.0 < "10");
	print "--------------------------";
	print "\"10\" == 10.0",("10" == 10.0);
	print "\"10\" != 10.0",("10" != 10.0);
	print "\"10\" >= 10.0",("10" >= 10.0);
	print "\"10\" <= 10.0",("10" <= 10.0);
	print "\"10\" >  10.0",("10" > 10.0);
	print "\"10\" <  10.0",("10" < 10.0);
	print "--------------------------";
	print "\"10\" == 10.1",("10" == 10.1);
	print "\"10\" != 10.1",("10" != 10.1);
	print "\"10\" >= 10.1",("10" >= 10.1);
	print "\"10\" <= 10.1",("10" <= 10.1);
	print "\"10\" >  10.1",("10" > 10.1);
	print "\"10\" <  10.1",("10" < 10.1);
	print 1.245230;
	print 12345678901234567890E20;
	print .123;
	print 0.123000;
	print -0.123000;
	print .123E-;
	print 0.123000;
	print -0.123000;
	print (-0.123000 + "123");
}

1==1 :		1
1==0 :		0
1.0==1 :		1
1.1==1 :		0
1.0!=1 :		0
1.1!=1 :		1
"abc" == "abc"		1
"abc" != "abc"		0
--------------------------
a == "" :		1
a >= "" :		1
a <= "" :		1
a >  "" :		0
a <  "" :		0
--------------------------
a == " " :		0
a >= " " :		0
a <= " " :		1
a >  " " :		0
a <  " " :		1
--------------------------
"" == a :		1
"" >= a:		1
"" <= a:		1
"" >  a:		0
"" <  a:		0
--------------------------
" " == a :		0
" " >= a:		1
" " <= a:		0
" " >  a:		1
" " <  a:		0
--------------------------
10 == "10"		1
10 != "10"		0
10 >= "10"		1
10 <= "10"		1
10 >  "10"		0
10 <  "10"		0
--------------------------
10 == "11"		0
10 != "11"		1
10 >= "11"		0
10 <= "11"		1
10 >  "11"		0
10 <  "11"		1
--------------------------
11 == "10"		0
11 != "10"		1
11 >= "10"		1
11 <= "10"		0
11 >  "10"		1
11 <  "10"		0
--------------------------
010 == "8"		1
010 != "8"		0
010 >= "8"		1
010 <= "8"		1
010 >  "8"		0
010 <  "8"		0
--------------------------
10 == "10.0"		0
10 != "10.0"		1
10 >= "10.0"		0
10 <= "10.0"		1
10 >  "10.0"		0
10 <  "10.0"		1
--------------------------
10.0 == "10"		1
10.0 != "10"		0
10.0 >= "10"		1
10.0 <= "10"		1
10.0 >  "10"		0
10.0 <  "10"		0
--------------------------
"10" == 10.0		1
"10" != 10.0		0
"10" >= 10.0		1
"10" <= 10.0		1
"10" >  10.0		0
"10" <  10.0		0
--------------------------
"10" == 10.1		0
"10" != 10.1		1
"10" >= 10.1		0
"10" <= 10.1		1
"10" >  10.1		0
"10" <  10.1		1
1.24523
1.23457e+39
0.123
0.123
-0.123
0.123
0.123
-0.123
122.877
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-013.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	CONVFMT = "%s";
	printf ("%s\n",10.34);
}

ERROR: CODE 104 LINE 3 COLUMN 2 - recursion detected in format conversion
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-014.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	a = 30;
	b = 30;
	c = 30;
	print a,b,c;
}

30 30 30
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-015.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 16 LINE 3 COLUMN 50 - block nested too deeply
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-016.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	printf "[[[[[%s]]]]\n",sprintf("abc %s abc",sprintf("def %s %s",sprintf("%s %s %s","xyz",1.2342,"xyz"),sprintf("ttt %s tttt",123.12)));
	printf "[[[[%s]]]]\n",sprintf("ttt %s tttt",123.12);
}

[[[[[abc def xyz 1.2342 xyz ttt 123.12 tttt abc]]]]
[[[[ttt 123.12 tttt]]]]
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-017.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function gety ()
{
	return (y)++;
}

function getx ()
{
	if ((x == 2))
		error();
	return (x)++;
}

function main ()
{
	x = 0;
	y = 0;
	print (getx() + gety());
	print (getx() + gety());
	print (getx() + gety());
	print (getx() + gety());
	return 999;
}

function error ()
{
	exit 200;
}

BEGIN {
	main();
}

END {
	print "END OF PROGRAM";
	return 10;
}
END {
	print "END OF PROGRAM 2";
	exit 100;
}
END {
	print "END OF PROGRAM 3";
	exit 900;
}
0
2
END OF PROGRAM
END OF PROGRAM 2
--------------------------------------------------------------------------------
[CMD]  qseawk  --call main --newline=on -d- -f lang-017.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function gety ()
{
	return (y)++;
}

function getx ()
{
	if ((x == 2))
		error();
	return (x)++;
}

function main ()
{
	x = 0;
	y = 0;
	print (getx() + gety());
	print (getx() + gety());
	print (getx() + gety());
	print (getx() + gety());
	return 999;
}

function error ()
{
	exit 200;
}

BEGIN {
	main();
}

END {
	print "END OF PROGRAM";
	return 10;
}
END {
	print "END OF PROGRAM 2";
	exit 100;
}
END {
	print "END OF PROGRAM 3";
	exit 900;
}
0
2
--------------------------------------------------------------------------------
[CMD]  qseawk  --explicit=on --newline=on -d- -f lang-018.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 48 LINE 1 COLUMN 8 - duplicate global variable 'ARGV'
--------------------------------------------------------------------------------
[CMD]  qseawk  --explicit=on --newline=on -d- -f lang-019.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 50 LINE 1 COLUMN 15 - '+' not a valid parameter name
--------------------------------------------------------------------------------
[CMD]  qseawk  --explicit=on --newline=on -d- -f lang-020.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 51 LINE 1 COLUMN 8 - '+' not a valid variable name
--------------------------------------------------------------------------------
[CMD]  qseawk  --explicit=on --newline=on -d- -f lang-021.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 51 LINE 3 COLUMN 8 - '+' not a valid variable name
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-022.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 24 LINE 2 COLUMN 9 - left parenthesis expected in place of '='
--------------------------------------------------------------------------------
[CMD]  qseawk  --explicit=on --newline=on -d- -f lang-023.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 29 LINE 5 COLUMN 20 - colon expected in place of ';'
--------------------------------------------------------------------------------
[CMD]  qseawk  --explicit=on --newline=on -d- -f lang-024.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	local __l0;
	__l0 = 21;
	print ((__l0 > 20))?1:2;
	c = ((__l0)++   ++(b));
	print __l0;
	print b;
	print c;
	print (99   ++(c));
	x = (("he"   "ll")   "o");
	x >>= " world";
	print x;
}

1
22
1
211
99212
hello world
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-025.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiix = 20;
	delete iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiix;
}

ERROR: CODE 79 LINE 3 COLUMN 9 - variable 'iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiix' not deletable
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-026.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	abc[20] = "abc";
	print abc[20];
	abc = 10;
	print abc;
}

abc
ERROR: CODE 87 LINE 4 COLUMN 2 - map 'abc' not assignable with a scalar
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-027.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 18 LINE 2 COLUMN 1 - invalid character '<NUL>'
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-028.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 42 LINE 2 COLUMN 10 - intrinsic function 'substr' redefined
--------------------------------------------------------------------------------
[CMD]  qseawk  --explicit=on --newline=on -d- -f lang-029.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
ERROR: CODE 43 LINE 9 COLUMN 9 - function 'abc' redefined
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-030.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	print 1;
	print 255;
	print 10;
	print 16;
	print 2;
	print 0;
	print 0;
	print "-----------------------";
	print 1;
	print 255;
	print 10;
	print 16;
	print 2;
	print 0;
	print 0;
	print "-----------------------";
	print -1;
	print -255;
	print -10;
	print -16;
	print -2;
	print 0;
	print 0;
}

1
255
10
16
2
0
0
-----------------------
1
255
10
16
2
0
0
-----------------------
-1
-255
-10
-16
-2
0
0
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-031.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	print match("hhhheeeo",/e+/);
	print RSTART,RLENGTH;
	print match("heeeo",/e/);
	print RSTART,RLENGTH;
	print match("heeeo",/t/);
	print RSTART,RLENGTH;
	print "--------------------------";
	print match("hhhheeeo","e+");
	print RSTART,RLENGTH;
	print match("heeeo","e");
	print RSTART,RLENGTH;
	print match("heeeo","t");
	print RSTART,RLENGTH;
	print "--------------------------";
}

5
5 3
2
2 1
0
0 -1
--------------------------
5
5 3
2
2 1
0
0 -1
--------------------------
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-032.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	a = 91;
	print ((a)++   10);
	print ((a)++   10);
	print ((a)++   10);
	print ((a)++   10);
	print ((a)++   10);
	print "---------------------";
	a = 91;
	print (++(a)   10);
}

9110
9210
9310
9410
9510
---------------------
9210
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -vdatadir=/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk -vdatafile=passwd.dat -f lang-033.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	while (((((("cat "   datadir)   "/")   datafile) | getline x) > 0))
		print x;
}

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh
proxy:x:13:13:proxy:/bin:/bin/sh
www-data:x:33:33:www-data:/var/www:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
list:x:38:38:Mailing List Manager:/var/list:/bin/sh
irc:x:39:39:ircd:/var/run/ircd:/bin/sh
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
libuuid:x:100:101::/var/lib/libuuid:/bin/sh
syslog:x:101:102::/home/syslog:/bin/false
klog:x:102:103::/home/klog:/bin/false
hplip:x:103:7:HPLIP system user,,,:/var/run/hplip:/bin/false
avahi-autoipd:x:104:110:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/bin/false
gdm:x:105:111:Gnome Display Manager:/var/lib/gdm:/bin/false
saned:x:106:113::/home/saned:/bin/false
pulse:x:107:114:PulseAudio daemon,,,:/var/run/pulse:/bin/false
messagebus:x:108:117::/var/run/dbus:/bin/false
polkituser:x:109:118:PolicyKit,,,:/var/run/PolicyKit:/bin/false
avahi:x:110:119:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/false
haldaemon:x:111:120:Hardware abstraction layer,,,:/var/run/hald:/bin/false
statd:x:112:65534::/var/lib/nfs:/bin/false
sshd:x:113:65534::/var/run/sshd:/usr/sbin/nologin
speech-dispatcher:x:114:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/sh
couchdb:x:115:116:CouchDB Administrator,,,:/var/lib/couchdb:/bin/bash
kernoops:x:116:65534:Kernel Oops Tracking Daemon,,,:/:/bin/false
mysql:x:117:124:MySQL Server,,,:/var/lib/mysql:/bin/false
openldap:x:118:125:OpenLDAP Server Account,,,:/nonexistent:/bin/false
postfix:x:119:126::/var/spool/postfix:/bin/false
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on --rwpipe=on -d- -f lang-034.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	print "15" || "sort";
	print "14" || "sort";
	print "13" || "sort";
	print "12" || "sort";
	print "11" || "sort";
	close("sort","r");
	print "-----";
	while ((("sort" || getline x) > 0))
		print "xx:",x;
}

-----
xx: 11
xx: 12
xx: 13
xx: 14
xx: 15
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -vdatadir=/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk -vdatafile=lang-035.dat1 -vgroupname=lang-035 -f lang-035.awk lang-035.dat2 </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	max_cid_vars = 100;
	datapath = ((datadir   "/")   datafile);
	first = 1;
	while (((getline x < datapath) > 0))
	{
		if (first)
		{
			first = 0;
			continue;
		}
		n = split(x,f,",");
		if ((n < 3))
			continue;
		if ((f[3] == ""))
			continue;
		for (suffix = 0; (suffix < max_cid_vars); (suffix)++)
		{
			oldval = tab[f[2],suffix];
			if ((oldval == ""))
			{
				tab[f[2],suffix] = f[3];
				break;
			}
		}
	}
}

/^lease[[:space:]]+.+[[:space:]]*{[[:space:]]*$/ {
	voice_no = 0;
}

{
	if ((($1 == "option") && ($2 == "agent.circuit-id")))
	{
		pos = index($0,"agent.circuit-id ");
		len = length($0);
		last = substr($0,len,1);
		adj = 0;
		if ((last != ";"))
			(adj)++;
		cid = substr($0,(pos + 17),(length($0) - ((pos + 17) + adj)));
		for (suffix = 0; (suffix < max_cid_vars); (suffix)++)
		{
			val = tab[cid,suffix];
			if ((val == ""))
				break;
			print (((("  info awk.voice-no-"   voice_no)   " ")   val)   ";");
			(voice_no)++;
		}
	}
	print $0;
	if ((($1 == "hardware") && ($2 == "ethernet")))
	{
		print (("  info awk.groupname \""   groupname)   "\";");
	}
}

# The format of this file is documented in the dhcpd.leases(5) manual page.
# This lease file was written by isc-dhcp-V3.1.1

lease 20.1.20.52 {
  starts 5 2009/08/07 08:33:03;
  ends 5 2009/08/07 08:38:14;
  tstp 5 2009/08/07 08:38:14;
  cltt 5 2009/08/07 08:33:03;
  binding state free;
  hardware ethernet 00:13:5e:4f:d2:d3;
  info awk.groupname "lang-035";
}
lease 20.1.20.57 {
  starts 1 2009/08/10 09:04:12;
  ends 2 2009/08/11 09:04:12;
  cltt 1 2009/08/10 09:04:12;
  binding state active;
  next binding state free;
  hardware ethernet 00:13:5e:50:23:6b;
  info awk.groupname "lang-035";
  info awk.voice-no-0 "68599021";
  option agent.circuit-id "BLM1500_AR3_ILAB ONT/9/1/1 /0.0";
  option agent.unknown-9 0:0:0:c1:8:45:52:49:43:53:53:4f:4e;
}
lease 20.1.20.54 {
  starts 1 2009/08/10 09:04:16;
  ends 2 2009/08/11 09:04:16;
  cltt 1 2009/08/10 09:04:16;
  binding state active;
  next binding state free;
  hardware ethernet 00:13:5e:50:25:aa;
  info awk.groupname "lang-035";
  info awk.voice-no-0 "68599011";
  option agent.circuit-id "BLM1500_AR3_ILAB ONT/9/1/2 /0.0";
  option agent.unknown-9 0:0:0:c1:8:45:52:49:43:53:53:4f:4e;
}
lease 20.1.20.55 {
  starts 1 2009/08/10 13:53:08;
  ends 2 2009/08/11 13:53:08;
  cltt 1 2009/08/10 13:53:08;
  binding state active;
  next binding state free;
  hardware ethernet 00:13:5e:50:20:af;
  info awk.groupname "lang-035";
  info awk.voice-no-0 "68599012";
  option agent.circuit-id "BLM1500_AR3_ILAB ONT/9/2/1 /0.0";
  option agent.unknown-9 0:0:0:c1:8:45:52:49:43:53:53:4f:4e;
}
lease 20.1.20.56 {
  starts 1 2009/08/10 13:53:42;
  ends 2 2009/08/11 13:53:42;
  cltt 1 2009/08/10 13:53:42;
  binding state active;
  next binding state free;
  hardware ethernet 00:13:5e:50:20:29;
  info awk.groupname "lang-035";
  info awk.voice-no-0 "68599022";
  option agent.circuit-id "BLM1500_AR3_ILAB ONT/9/2/2 /0.0";
  option agent.unknown-9 0:0:0:c1:8:45:52:49:43:53:53:4f:4e;
}
lease 10.218.255.53 {
  starts 5 2009/08/07 08:18:04;
  ends 5 2009/08/07 08:28:04;
  tstp 5 2009/08/07 08:28:04;
  cltt 5 2009/08/07 08:18:04;
  binding state free;
  hardware ethernet 00:1b:5b:9c:4f:7d;
  info awk.groupname "lang-035";
  uid "\001\000\033[\234O}";
}
lease 10.218.255.54 {
  starts 5 2009/08/07 08:32:37;
  ends 5 2009/08/07 08:42:37;
  tstp 5 2009/08/07 08:42:37;
  cltt 5 2009/08/07 08:32:37;
  binding state free;
  hardware ethernet 00:1b:5b:9c:1b:35;
  info awk.groupname "lang-035";
  uid "\001\000\033[\234\0335";
}
lease 10.218.255.59 {
  starts 5 2009/08/07 10:39:01;
  ends 6 2009/08/08 10:29:45;
  tstp 6 2009/08/08 10:29:45;
  cltt 5 2009/08/07 10:39:01;
  binding state free;
  hardware ethernet 00:1f:b3:79:7e:30;
  info awk.groupname "lang-035";
  uid "\001\000\037\263y~0";
}
lease 10.218.255.58 {
  starts 0 2009/08/09 14:21:00;
  ends 1 2009/08/10 09:13:42;
  tstp 1 2009/08/10 09:13:42;
  cltt 0 2009/08/09 14:21:00;
  binding state free;
  hardware ethernet 00:19:e4:43:0e:c8;
  info awk.groupname "lang-035";
  uid "\001\000\031\344C\016\310";
}
lease 10.218.255.55 {
  starts 1 2009/08/10 09:02:31;
  ends 2 2009/08/11 09:02:31;
  cltt 1 2009/08/10 09:02:31;
  binding state active;
  next binding state free;
  hardware ethernet 00:1b:5b:9c:90:00;
  info awk.groupname "lang-035";
  uid "\001\000\033[\234\220\000";
  info awk.voice-no-0 "68599019";
  info awk.voice-no-1 "68599014";
  option agent.circuit-id "AR_Remote atm 1/1/03/12:2.100";
  option agent.remote-id "22M-fast";
}
lease 10.218.255.52 {
  starts 1 2009/08/10 09:04:04;
  ends 2 2009/08/11 09:04:04;
  cltt 1 2009/08/10 09:04:04;
  binding state active;
  next binding state free;
  hardware ethernet 00:1b:5b:9c:81:35;
  info awk.groupname "lang-035";
  uid "\001\000\033[\234\2015";
}
lease 10.218.255.56 {
  starts 1 2009/08/10 09:06:09;
  ends 2 2009/08/11 09:06:09;
  cltt 1 2009/08/10 09:06:09;
  binding state active;
  next binding state free;
  hardware ethernet 00:1e:c7:fb:29:7d;
  info awk.groupname "lang-035";
  uid "\001\000\036\307\373)}";
}
lease 10.218.255.57 {
  starts 1 2009/08/10 09:14:33;
  ends 2 2009/08/11 09:14:33;
  cltt 1 2009/08/10 09:14:33;
  binding state active;
  next binding state free;
  hardware ethernet 00:1e:c7:fb:29:4d;
  info awk.groupname "lang-035";
  uid "\001\000\036\307\373)M";
}
lease 10.218.255.66 {
  starts 1 2009/08/10 13:57:24;
  ends 2 2009/08/11 13:57:24;
  cltt 1 2009/08/10 13:57:24;
  binding state active;
  next binding state free;
  hardware ethernet 00:1a:04:f9:e2:90;
  info awk.groupname "lang-035";
  uid "\001\000\032\004\371\342\220";
  info awk.voice-no-0 "68599018";
  option agent.circuit-id "AR_Remote atm 1/1/03/02:2.100";
  option agent.remote-id "3play";
}
lease 10.218.255.60 {
  starts 1 2009/08/10 17:25:17;
  ends 2 2009/08/11 17:25:17;
  cltt 1 2009/08/10 17:25:17;
  binding state active;
  next binding state free;
  hardware ethernet 00:1e:c7:fb:29:1d;
  info awk.groupname "lang-035";
  uid "\001\000\036\307\373)\035";
  info awk.voice-no-0 "68599017";
  info awk.voice-no-1 "68599013";
  option agent.circuit-id "AL_AM3_LAB atm 1/1/01/01:2.100";
  option agent.remote-id "Testing DHCP";
}
# The format of this file is documented in the dhcpd.leases(5) manual page.
# This lease file was written by isc-dhcp-V3.1.1

lease 10.218.255.151 {
  starts 5 2009/08/07 08:09:38;
  ends 5 2009/08/07 08:13:59;
  tstp 5 2009/08/07 08:13:59;
  cltt 5 2009/08/07 08:09:38;
  binding state free;
  hardware ethernet 00:1b:5b:9c:90:00;
  info awk.groupname "lang-035";
  uid "\001\000\033[\234\220\000";
}
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-036.awk lang-036.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
{
	if (($0 ~ /^-+$/))
	{
		(getline x);
		printf " %s\n",x;
		nobar = 0;
	}
	else
	{
		if (nobar)
			printf "\n";
		printf "%s",$0;
		nobar = 1;
	}
}

ab...c AAA

de...f
gh...i AAA1

jk...l
mn...o
pq...r AAA2



kbs ddd
dif cccc
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-037.awk lang-037.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	RS = "\n-+\n";
	first = 1;
}

{
	if ((!(first)))
		printf " ";
	printf "%s",$0;
	first = 0;
}

ab...c AAA

de...f
gh...i AAA1

jk...l
mn...o
pq...r AAA2



kbs ddd
dif cccc
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-038.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	xstr = "abcdefabcdefabcdef";
	xsub = "abc";
	xlen = length(xsub);
	i = 1;
	while ((i = index(xstr,xsub,i) > 0))
	{
		print i,substr(xstr,i,xlen);
		i += xlen;
	}
	print "----------------";
	i = 1;
	while ((match(xstr,xsub,i) > 0))
	{
		print RSTART,substr(xstr,RSTART,RLENGTH);
		i = (RSTART + RLENGTH);
	}
}

1 abc
7 abc
13 abc
----------------
1 abc
7 abc
13 abc
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-039.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	print (length()   11);
	print length(11);
}

011
2
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-040.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	for (x in y)
		print x;
}

--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-041.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	abc = 20;
	print (abc   10);
}

2010
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-042.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	print //;
	print /=/;
	print /.*/;
	a = 5;
	a /= 10;
	print a;
	for (IGNORECASE = 0; (IGNORECASE <= 1); (IGNORECASE)++)
	{
		print "IGNORECASE=",IGNORECASE;
		print ("abc" ~ /^[[:upper:]]+$/);
		print ("abc" ~ /^[[:lower:]]+$/);
		print ("ABC" ~ /^[[:upper:]]+$/);
		print ("ABC" ~ /^[[:lower:]]+$/);
		print ("AbC" ~ /^[[:upper:]]+$/);
		print ("aBc" ~ /^[[:lower:]]+$/);
	}
}

1
0
1
0.5
IGNORECASE= 0
0
1
1
0
0
0
IGNORECASE= 1
1
1
1
1
1
1
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-043.awk lang-043.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	RS = "[\t\n\v\f\r ]*[\r\n]+[\t\n\v\f\r ]*";
}

{
	print $0;
}

abcd
dcba
j
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-044.awk lang-044.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	RS = "";
}

{
	print (("["   $0)   "]");
}

[abc
this is the second line]
[def
vwxyz
this is the second second line]
[   ttttt
killer]
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -f lang-045.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	for (i = -10.000000; (i < 10.0); (i)++)
	{
		print sin(i);
		print cos(i);
		print tan(i);
		print atan(i);
		print atan2(i,1);
		print log(i);
		print exp(i);
		print sqrt(i);
	}
}

0.544021
-0.839072
-0.648361
-1.47113
-1.47113
nan
4.53999e-05
-nan
-0.412118
-0.91113
0.452316
-1.46014
-1.46014
nan
0.00012341
-nan
-0.989358
-0.1455
6.79971
-1.44644
-1.44644
nan
0.000335463
-nan
-0.656987
0.753902
-0.871448
-1.4289
-1.4289
nan
0.000911882
-nan
0.279415
0.96017
0.291006
-1.40565
-1.40565
nan
0.00247875
-nan
0.958924
0.283662
3.38052
-1.3734
-1.3734
nan
0.00673795
-nan
0.756802
-0.653644
-1.15782
-1.32582
-1.32582
nan
0.0183156
-nan
-0.14112
-0.989992
0.142547
-1.24905
-1.24905
nan
0.0497871
-nan
-0.909297
-0.416147
2.18504
-1.10715
-1.10715
nan
0.135335
-nan
-0.841471
0.540302
-1.55741
-0.785398
-0.785398
nan
0.367879
-nan
0
1
0
0
0
-inf
1
0
0.841471
0.540302
1.55741
0.785398
0.785398
0
2.71828
1
0.909297
-0.416147
-2.18504
1.10715
1.10715
0.693147
7.38906
1.41421
0.14112
-0.989992
-0.142547
1.24905
1.24905
1.09861
20.0855
1.73205
-0.756802
-0.653644
1.15782
1.32582
1.32582
1.38629
54.5982
2
-0.958924
0.283662
-3.38052
1.3734
1.3734
1.60944
148.413
2.23607
-0.279415
0.96017
-0.291006
1.40565
1.40565
1.79176
403.429
2.44949
0.656987
0.753902
0.871448
1.4289
1.4289
1.94591
1096.63
2.64575
0.989358
-0.1455
-6.79971
1.44644
1.44644
2.07944
2980.96
2.82843
0.412118
-0.91113
-0.452316
1.46014
1.46014
2.19722
8103.08
3
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -d- -vdatadir=/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk -vdatafile=lang-046.dat1 -f lang-046.awk lang-046.dat2 </dev/stdin 2>&1 
--------------------------------------------------------------------------------
1

((getline < ((datadir   "/")   datafile)) >= 0)

2 AAAAAAAAAAAAAAAAAAAAAAAAA
1 AAAAAAAAAAAAAAAAAAAAAAAAA
2 BBBBBBBBBBBBBBBBBBBBBBBBB
1 BBBBBBBBBBBBBBBBBBBBBBBBB
2 CCCCCCCCCCCCCCCCCCCCCCCCC
1 CCCCCCCCCCCCCCCCCCCCCCCCC
2 DDDDDDDDDDDDDDDDDDDDDDDDD
1 DDDDDDDDDDDDDDDDDDDDDDDDD
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on --tolerant=on -d- -f lang-047.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
BEGIN {
	print (print (print (print 10)));
	print (print 10 > "/tmp/should/not/be/creatable");
	if (((print 10 > "/tmp/should/not/be/creatable") <= -1))
		print "FAILURE";
	else
		print "SUCCESS";
	print "------------------------------------";
	a = (1   (print 10 > "/tmp/should/not/be/creatable"));
	print a;
	print "------------------------------------";
	b = (++(a)   (print 10));
	printf "%d\n",b;
	print "------------------------------------";
	printf ("%d\n",(b + ((print (print (print 80))) + 40)));
	print "------------------------------------";
	printf ("%d\n",(b + ((print (print (print (30   50)))) + 40)));
	print "------------------------------------";
	$(print 0 > "/dev/null") = "this is wonderful";
	print $0;
	print "------------------------------------";
	$((getline dummy) > "/dev/zero") = "that";
	print $0;
	print "------------------------------------";
	x[0] = 20;
	abc = ((print ("hello","world",(1,abc = 20,abc = 45))) in x);
	print abc;
}

10
0
0
0
-1
FAILURE
------------------------------------
1-1
------------------------------------
10
20
------------------------------------
80
0
0
60
------------------------------------
3050
0
0
60
------------------------------------
this is wonderful
------------------------------------
that is wonderful
------------------------------------
hello world 45
1
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -F: -f columnate.awk passwd.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
root               x  0      0      root                                /root                       /bin/bash
daemon             x  1      1      daemon                              /usr/sbin                   /bin/sh
bin                x  2      2      bin                                 /bin                        /bin/sh
sys                x  3      3      sys                                 /dev                        /bin/sh
sync               x  4      65534  sync                                /bin                        /bin/sync
games              x  5      60     games                               /usr/games                  /bin/sh
man                x  6      12     man                                 /var/cache/man              /bin/sh
lp                 x  7      7      lp                                  /var/spool/lpd              /bin/sh
mail               x  8      8      mail                                /var/mail                   /bin/sh
news               x  9      9      news                                /var/spool/news             /bin/sh
uucp               x  10     10     uucp                                /var/spool/uucp             /bin/sh
proxy              x  13     13     proxy                               /bin                        /bin/sh
www-data           x  33     33     www-data                            /var/www                    /bin/sh
backup             x  34     34     backup                              /var/backups                /bin/sh
list               x  38     38     Mailing List Manager                /var/list                   /bin/sh
irc                x  39     39     ircd                                /var/run/ircd               /bin/sh
gnats              x  41     41     Gnats Bug-Reporting System (admin)  /var/lib/gnats              /bin/sh
nobody             x  65534  65534  nobody                              /nonexistent                /bin/sh
libuuid            x  100    101                                        /var/lib/libuuid            /bin/sh
syslog             x  101    102                                        /home/syslog                /bin/false
klog               x  102    103                                        /home/klog                  /bin/false
hplip              x  103    7      HPLIP system user,,,                /var/run/hplip              /bin/false
avahi-autoipd      x  104    110    Avahi autoip daemon,,,              /var/lib/avahi-autoipd      /bin/false
gdm                x  105    111    Gnome Display Manager               /var/lib/gdm                /bin/false
saned              x  106    113                                        /home/saned                 /bin/false
pulse              x  107    114    PulseAudio daemon,,,                /var/run/pulse              /bin/false
messagebus         x  108    117                                        /var/run/dbus               /bin/false
polkituser         x  109    118    PolicyKit,,,                        /var/run/PolicyKit          /bin/false
avahi              x  110    119    Avahi mDNS daemon,,,                /var/run/avahi-daemon       /bin/false
haldaemon          x  111    120    Hardware abstraction layer,,,       /var/run/hald               /bin/false
statd              x  112    65534                                      /var/lib/nfs                /bin/false
sshd               x  113    65534                                      /var/run/sshd               /usr/sbin/nologin
speech-dispatcher  x  114    29     Speech Dispatcher,,,                /var/run/speech-dispatcher  /bin/sh
couchdb            x  115    116    CouchDB Administrator,,,            /var/lib/couchdb            /bin/bash
kernoops           x  116    65534  Kernel Oops Tracking Daemon,,,      /                           /bin/false
mysql              x  117    124    MySQL Server,,,                     /var/lib/mysql              /bin/false
openldap           x  118    125    OpenLDAP Server Account,,,          /nonexistent                /bin/false
postfix            x  119    126                                        /var/spool/postfix          /bin/false
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on --include=on -f levenshtein-utests.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
3:	Correct distance between 'kitten' and 'sitting'
3:	Correct distance between 'Saturday' and 'Sunday'
1:	Correct distance between 'acc' and 'ac'
2:	Correct distance between 'foo' and 'four'
0:	Correct distance between 'foo' and 'foo'
2:	Correct distance between 'cow' and 'cat'
5:	Correct distance between 'cat' and 'moocow'
5:	Correct distance between 'cat' and 'cowmoo'
1:	Correct distance between 'sebastian' and 'sebastien'
5:	Correct distance between 'more' and 'cowbell'
1:	Correct distance between 'freshpack' and 'freshpak'
1:	Correct distance between 'freshpak' and 'freshpack'
--------------------------------------------------------------------------------
[CMD]  qseawk  --newline=on -v target=89000 -f rcalc.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
Result      Ra   Rb  Connect    Error

88800.00    82000    6800  series    -0.22%
89000.00    56000   33000  series  
89000.00    62000   27000  series  
89130.43   820000  100000  parallel  +0.15%
89137.93   470000  110000  parallel  +0.15%
89189.19   220000  150000  parallel  +0.21%
--------------------------------------------------------------------------------
[CMD]  qseawk   -f quicksort.awk quicksort.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
0.0000000000
0.11111111111111111111111111111
1
0xA
11.2839091
12
29
0b11111
34
35
92
301
493
19123
1.E12
99X
--------------------------------------------------------------------------------
[CMD]  qseawk  -vQSEAWK="/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/cmd/awk/qseawk" -vSCRIPT_PATH="/home/hyung-hwan/nfs.exports/workspace/qse/x86_64/linux-wchar-debug/../../src/regress/awk" -f quicksort2.awk quicksort2.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
0.0000000000
0.11111111111111111111111111111
1
0xA
11.2839091
12
29
0b11111
34
35
92
301
493
19123
1.E12
99X
--------------------------------------------------------------------------------
[CMD]  qseawk   -f asm.awk asm.s <asm.dat 2>&1 
--------------------------------------------------------------------------------
549
--------------------------------------------------------------------------------
[CMD]  qseawk   -f stripcomment.awk stripcomment.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
 

#include <stdio.h>
int main ()
{
	 
	printf ("hello, world\n");
	return 0;
}
 --------------------------------------------------------------------------------
[CMD]  qseawk   -f wordfreq.awk wordfreq.awk </dev/stdin 2>&1 
--------------------------------------------------------------------------------
_ 2
a 2
print 2
case 1
tolower 1
i 4
freq 3
distinctions 1
frequencies 1
list 1
alnum 2
nf 1
punctuation 1
remove 2
awk 1
end 1
gsub 2
of 1
word 4
wordfreq 1
for 2
in 1
0 3
1 1
blank 2
--------------------------------------------------------------------------------
[CMD]  qseawk   -f hanoi.awk  </dev/stdin 2>&1 
--------------------------------------------------------------------------------
0 54321
1 
2 

0 5432
1 1
2 

0 543
1 1
2 2

0 543
1 
2 21

0 54
1 3
2 21

0 541
1 3
2 2

0 541
1 32
2 

0 54
1 321
2 

0 5
1 321
2 4

0 5
1 32
2 41

0 52
1 3
2 41

0 521
1 3
2 4

0 521
1 
2 43

0 52
1 1
2 43

0 5
1 1
2 432

0 5
1 
2 4321

0 
1 5
2 4321

0 1
1 5
2 432

0 1
1 52
2 43

0 
1 521
2 43

0 3
1 521
2 4

0 3
1 52
2 41

0 32
1 5
2 41

0 321
1 5
2 4

0 321
1 54
2 

0 32
1 541
2 

0 3
1 541
2 2

0 3
1 54
2 21

0 
1 543
2 21

0 1
1 543
2 2

0 1
1 5432
2 

0 
1 54321
2 

--------------------------------------------------------------------------------
[CMD]  qseawk   -f indent.awk indent.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
#!/bin/sh

if [ $# -ne 0 ]
then
    echo  "not the right usage"
    exit 1
fi

while true
do
    sleep 20
done
--------------------------------------------------------------------------------
[CMD]  qseawk  -d- -f lisp/awklisp lisp/startup lisp/fib.lsp </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function eval_rands (__p0)
{
	for (; (__p0 != NIL); __p0 = cdr[__p0])
		stack[(stack_ptr)++] = eval(car[__p0]);
}

function def_prim (__p0, __p1, __p2)
{
	__p2 = string_to_symbol(__p0);
	value[__p2] = string_to_symbol(sprintf("#<Primitive %s>",__p0));
	if ((__p1 != ""))
		num_params[value[__p2]] = __p1;
	return value[__p2];
}

function is_symbol (__p0)
{
	return ((__p0 % 4) == 2);
}

function is_number (__p0)
{
	return ((__p0 % 4) == 0);
}

function read (__p0, __p1)
{
	skip_blanks();
	if ((token == eof))
		if (__p0)
			error("Unexpected EOF");
		else
			return THE_EOF_OBJECT;
	if ((token == "("))
	{
		advance();
		__p1 = NIL;
		for (; ; )
		{
			skip_blanks();
			if ((token == "."))
			{
				advance();
				after_dot = read(1);
				skip_blanks();
				if ((token != ")"))
					error("')' expected");
				advance();
				return nreverse(__p1,after_dot);
			}
			else
				if ((token == ")"))
				{
					advance();
					return nreverse(__p1,NIL);
				}
				else
				{
					protect(__p1);
					__p1 = cons(read(1),__p1);
					unprotect();
				}
		}
	}
	else
		if ((token == "'"))
		{
			advance();
			return cons(QUOTE,cons(read(1),NIL));
		}
		else
			if ((token ~ /^-?[0-9]+$/))
			{
				__p1 = make_number(token);
				advance();
				return __p1;
			}
			else
			{
				__p1 = string_to_symbol(token);
				advance();
				return __p1;
			}
}

function protect (__p0)
{
	protected[++(protected_ptr)] = __p0;
}

function mark (__p0)
{
	while ((is_pair(__p0) && (!((__p0 in marks)))))
	{
		marks[__p0] = 1;
		mark(car[__p0]);
		__p0 = cdr[__p0];
	}
}

function write_expr (__p0)
{
	if (is_atom(__p0))
	{
		if ((!(is_symbol(__p0))))
			printf ("%d",numeric_value(__p0));
		else
		{
			if ((!((__p0 in printname))))
				error((("BUG: "   __p0)   " has no printname"));
			printf ("%s",printname[__p0]);
		}
	}
	else
	{
		printf "(";
		write_expr(car[__p0]);
		for (__p0 = cdr[__p0]; is_pair(__p0); __p0 = cdr[__p0])
		{
			printf " ";
			write_expr(car[__p0]);
		}
		if ((__p0 != NIL))
		{
			printf " . ";
			write_expr(__p0);
		}
		printf ")";
	}
}

function make_number (__p0)
{
	return (__p0 * 4);
}

function print_expr (__p0)
{
	write_expr(__p0);
	print "";
}

function progn (__p0)
{
	for (; (cdr[__p0] != NIL); __p0 = cdr[__p0])
		eval(car[__p0]);
	return eval(car[__p0]);
}

function string_to_symbol (__p0)
{
	if ((__p0 in intern))
		return intern[__p0];
	symbol_ptr += 4;
	intern[__p0] = symbol_ptr;
	printname[symbol_ptr] = __p0;
	return symbol_ptr;
}

function cons (__p0, __p1)
{
	while ((pair_ptr in marks))
	{
		delete marks[pair_ptr];
		pair_ptr += 4;
	}
	if ((pair_ptr == pair_limit))
		gc(__p0,__p1);
	car[pair_ptr] = __p0;
	cdr[pair_ptr] = __p1;
	pair_ptr += 4;
	return (pair_ptr - 4);
}

function listify_args (__p0, __p1)
{
	__p1 = NIL;
	for (__p0 = (stack_ptr - 1); (frame_ptr <= __p0); --(__p0))
		__p1 = cons(stack[__p0],__p1);
	return __p1;
}

function numeric_value (__p0)
{
	if (((__p0 % 4) != 0))
		error("Not a number");
	return (__p0 / 4);
}

function skip_blanks ()
{
	while ((token ~ /^[ 	]*$/))
		advance();
}

function apply (__p0)
{
	if (profiling)
		++(call_count[__p0]);
	if ((car[__p0] == LAMBDA))
	{
		extend_env(car[cdr[__p0]]);
		result = progn(cdr[cdr[__p0]]);
		unwind_env(car[cdr[__p0]]);
		return result;
	}
	if (((__p0 in num_params) && (num_params[__p0] != (stack_ptr - frame_ptr))))
		error(("Wrong number of arguments to "   printname[cdr[__p0]]));
	if ((__p0 == CAR))
		return car[is(a_pair,stack[frame_ptr])];
	if ((__p0 == CDR))
		return cdr[is(a_pair,stack[frame_ptr])];
	if ((__p0 == CONS))
		return cons(stack[frame_ptr],stack[(frame_ptr + 1)]);
	if ((__p0 == NULL))
		return ((stack[frame_ptr] == NIL))?T:NIL;
	if ((__p0 == EQ))
		return ((stack[frame_ptr] == stack[(frame_ptr + 1)]))?T:NIL;
	if ((__p0 == ATOMP))
		return (is_atom(stack[frame_ptr]))?T:NIL;
	if ((__p0 == ADD))
		return (is(a_number,stack[frame_ptr]) + is(a_number,stack[(frame_ptr + 1)]));
	if ((__p0 == SUB))
		return (is(a_number,stack[frame_ptr]) - is(a_number,stack[(frame_ptr + 1)]));
	if ((__p0 == MUL))
		return make_number((numeric_value(stack[frame_ptr]) * numeric_value(stack[(frame_ptr + 1)])));
	if ((__p0 == DIV))
		return make_number(int((numeric_value(stack[frame_ptr]) / numeric_value(stack[(frame_ptr + 1)]))));
	if ((__p0 == MOD))
		return make_number((numeric_value(stack[frame_ptr]) % numeric_value(stack[(frame_ptr + 1)])));
	if ((__p0 == LT))
		return (((stack[frame_ptr] + 0) < (stack[(frame_ptr + 1)] + 0)))?T:NIL;
	if ((__p0 == GET))
		return (((stack[frame_ptr],stack[(frame_ptr + 1)]) in property))?property[stack[frame_ptr],stack[(frame_ptr + 1)]]:NIL;
	if ((__p0 == PUT))
		return property[stack[frame_ptr],stack[(frame_ptr + 1)]] = stack[(frame_ptr + 2)];
	if ((__p0 == CADR))
		return car[is(a_pair,cdr[is(a_pair,stack[frame_ptr])])];
	if ((__p0 == CDDR))
		return cdr[is(a_pair,cdr[is(a_pair,stack[frame_ptr])])];
	if ((__p0 == LIST))
		return listify_args();
	if ((__p0 == SYMBOLP))
		return (is_symbol(stack[frame_ptr]))?T:NIL;
	if ((__p0 == PAIRP))
		return (is_pair(stack[frame_ptr]))?T:NIL;
	if ((__p0 == NUMBERP))
		return (is_number(stack[frame_ptr]))?T:NIL;
	if ((__p0 == SETCAR))
		return car[is(a_pair,stack[frame_ptr])] = stack[(frame_ptr + 1)];
	if ((__p0 == SETCDR))
		return cdr[is(a_pair,stack[frame_ptr])] = stack[(frame_ptr + 1)];
	if ((__p0 == APPLY))
		return do_apply(stack[frame_ptr],stack[(frame_ptr + 1)]);
	if ((__p0 == EVAL))
		return eval(stack[frame_ptr]);
	if ((__p0 == NREV))
		return nreverse(stack[frame_ptr],NIL);
	if ((__p0 == WRITE))
	{
		write_expr(stack[frame_ptr]);
		printf " ";
		return NIL;
	}
	if ((__p0 == NEWLINE))
	{
		printf "\n";
		return NIL;
	}
	if ((__p0 == READ))
		return read();
	if ((__p0 == RANDOM))
		return make_number(int((rand() * numeric_value(stack[frame_ptr]))));
	if ((__p0 == GENSYM))
		return string_to_symbol(("#G"   ++(gensym_counter)));
	if ((__p0 == ERROR))
	{
		printf "Error!\n";
		print_expr(listify_args());
		exit 1;
	}
	error("Unknown procedure type");
}

function error (__p0)
{
	print ("ERROR: "   __p0) > "/dev/stderr";
	exit 1;
}

function gc (__p0, __p1, __p2, __p3)
{
	if (loud_gc)
		printf "\nGC..." > "/dev/stderr";
	mark(__p0);
	mark(__p1);
	for (__p2 in protected)
		mark(protected[__p2]);
	for (__p2 in stack)
		mark(stack[__p2]);
	for (__p2 in value)
		mark(value[__p2]);
	for (__p2 in property)
	{
		__p3 = index(SUBSEP,__p2);
		mark(substr(__p2,1,(__p3 - 1)));
		mark(substr(__p2,(__p3 + 1)));
		mark(property[__p2]);
	}
	pair_ptr = a_pair;
	while ((pair_ptr in marks))
	{
		delete marks[pair_ptr];
		pair_ptr += 4;
	}
	if ((pair_ptr == pair_limit))
	{
		if (loud_gc)
			printf "Expanding heap..." > "/dev/stderr";
		pair_limit += (4 * heap_increment);
	}
}

function extend_env (__p0, __p1, __p2)
{
	for (__p1 = frame_ptr; (__p0 != NIL); __p0 = cdr[__p0])
	{
		if ((__p1 == stack_ptr))
			error("Too many arguments to procedure");
		__p2 = value[car[__p0]];
		value[car[__p0]] = stack[__p1];
		stack[__p1] = __p2;
		++(__p1);
	}
	if ((__p1 != stack_ptr))
		error("Not enough arguments to procedure");
}

function is_atom (__p0)
{
	return ((__p0 % 4) != 1);
}

function is_pair (__p0)
{
	return ((__p0 % 4) == 1);
}

function eval (__p0, __p1)
{
	if (is_atom(__p0))
		if (is_symbol(__p0))
		{
			if ((!((__p0 in value))))
				error(("Unbound variable: "   printname[__p0]));
			return value[__p0];
		}
		else
			return __p0;
	op = car[__p0];
	if ((!((op in is_special))))
	{
		__p1 = frame_ptr;
		frame_ptr = stack_ptr;
		eval_rands(cdr[__p0]);
		protect(proc = eval(car[__p0]));
		result = apply(proc);
		unprotect();
		stack_ptr = frame_ptr;
		frame_ptr = __p1;
		return result;
	}
	if ((op == QUOTE))
		return car[cdr[__p0]];
	if ((op == LAMBDA))
		return __p0;
	if ((op == IF))
		return ((eval(car[cdr[__p0]]) != NIL))?eval(car[cdr[cdr[__p0]]]):eval(car[cdr[cdr[cdr[__p0]]]]);
	if ((op == PROGN))
		return progn(cdr[__p0]);
	if ((op == SETQ))
	{
		if ((!((car[cdr[__p0]] in value))))
			error(("Unbound variable: "   printname[car[cdr[__p0]]]));
		return value[car[cdr[__p0]]] = eval(car[cdr[cdr[__p0]]]);
	}
	if ((op == WHILE))
	{
		while ((eval(car[cdr[__p0]]) != NIL))
			progn(cdr[cdr[__p0]]);
		return NIL;
	}
	if ((op == DEFINE))
	{
		value[car[cdr[__p0]]] = eval(car[cdr[cdr[__p0]]]);
		return car[cdr[__p0]];
	}
	error("BUG: Unknown special form");
}

function is (__p0, __p1)
{
	if (((__p1 % 4) != __p0))
		error(((("Expected a "   type_name[__p0])   ", not a ")   type_name[(__p1 % 4)]));
	return __p1;
}

function unwind_env (__p0, __p1)
{
	for (__p1 = frame_ptr; (__p0 != NIL); __p0 = cdr[__p0])
	{
		if ((stack[__p1] == ""))
			delete value[car[__p0]];
		else
			value[car[__p0]] = stack[__p1];
		++(__p1);
	}
}

function nreverse (__p0, __p1, __p2)
{
	while (is_pair(__p0))
	{
		__p2 = cdr[__p0];
		cdr[__p0] = __p1;
		__p1 = __p0;
		__p0 = __p2;
	}
	if ((__p0 != NIL))
		error("Not a proper list - reverse!");
	return __p1;
}

function advance ()
{
	if ((token == eof))
		return eof;
	if ((token == ""))
	{
		if (((getline line) <= 0))
		{
			token = eof;
			return;
		}
	}
	if (((match(line,"^[()'.]") || match(line,"^[_A-Za-z0-9=!@$%&*<>?+\\-*/:]+")) || match(line,"^[ \\t]+")))
	{
		token = substr(line,RSTART,RLENGTH);
		line = substr(line,(RLENGTH + 1));
	}
	else
		if (((line == "") || (substr(line,1,1) == ";")))
			token = "";
		else
			error(("Lexical error starting at "   line));
}

function do_apply (__p0, __p1, __p2)
{
	__p2 = frame_ptr;
	frame_ptr = stack_ptr;
	for (; is_pair(__p1); __p1 = cdr[__p1])
		stack[(stack_ptr)++] = car[__p1];
	if ((__p1 != NIL))
		error("Bad argument to APPLY: not a proper list");
	result = apply(__p0);
	stack_ptr = frame_ptr;
	frame_ptr = __p2;
	return result;
}

function unprotect ()
{
	--(protected_ptr);
}

BEGIN {
	a_number = 0;
	pair_ptr = a_pair = 1;
	symbol_ptr = a_symbol = 2;
	type_name[a_number] = "number";
	type_name[a_pair] = "pair";
	type_name[a_symbol] = "symbol";
}

BEGIN {
	srand();
	frame_ptr = stack_ptr = 0;
	if ((heap_increment == ""))
		heap_increment = 1500;
	pair_limit = (a_pair + (4 * heap_increment));
	NIL = string_to_symbol("nil");
	T = string_to_symbol("t");
	value[NIL] = NIL;
	value[T] = T;
	car[NIL] = cdr[NIL] = NIL;
	THE_EOF_OBJECT = string_to_symbol("#eof");
	value[string_to_symbol("the-eof-object")] = THE_EOF_OBJECT;
	eof = "(eof)";
	QUOTE = string_to_symbol("quote");
	is_special[QUOTE] = 1;
	LAMBDA = string_to_symbol("lambda");
	is_special[LAMBDA] = 1;
	IF = string_to_symbol("if");
	is_special[IF] = 1;
	SETQ = string_to_symbol("set!");
	is_special[SETQ] = 1;
	DEFINE = string_to_symbol("define");
	is_special[DEFINE] = 1;
	PROGN = string_to_symbol("begin");
	is_special[PROGN] = 1;
	WHILE = string_to_symbol("while");
	is_special[WHILE] = 1;
	EQ = def_prim("eq?",2);
	NULL = def_prim("null?",1);
	CAR = def_prim("car",1);
	CDR = def_prim("cdr",1);
	CADR = def_prim("cadr",1);
	CDDR = def_prim("cddr",1);
	CONS = def_prim("cons",2);
	LIST = def_prim("list");
	EVAL = def_prim("eval",1);
	APPLY = def_prim("apply",2);
	READ = def_prim("read",0);
	WRITE = def_prim("write",1);
	NEWLINE = def_prim("newline",0);
	ADD = def_prim("+",2);
	SUB = def_prim("-",2);
	MUL = def_prim("*",2);
	DIV = def_prim("quotient",2);
	MOD = def_prim("remainder",2);
	LT = def_prim("<",2);
	GET = def_prim("get",2);
	PUT = def_prim("put",3);
	ATOMP = def_prim("atom?",1);
	PAIRP = def_prim("pair?",1);
	SYMBOLP = def_prim("symbol?",1);
	NUMBERP = def_prim("number?",1);
	SETCAR = def_prim("set-car!",2);
	SETCDR = def_prim("set-cdr!",2);
	NREV = def_prim("reverse!",1);
	GENSYM = def_prim("gensym",0);
	RANDOM = def_prim("random",1);
	ERROR = def_prim("error");
	DRIVER = string_to_symbol("top-level-driver");
}

BEGIN {
	for (; ; )
	{
		if (((DRIVER in value) && (value[DRIVER] != NIL)))
			apply(value[DRIVER]);
		else
		{
			expr = read();
			if ((expr == THE_EOF_OBJECT))
				break;
			protect(expr);
			print_expr(eval(expr));
			unprotect();
		}
	}
	if (profiling)
		for (proc in call_count)
		{
			printf ("%5d ",call_count[proc]);
			print_expr(proc);
		}
}

--------------------------------------------------------------------------------
[CMD]  qseawk  -d- -f lisp/awklisp lisp/startup lisp/numbers lisp/numbers.dat </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function eval_rands (__p0)
{
	for (; (__p0 != NIL); __p0 = cdr[__p0])
		stack[(stack_ptr)++] = eval(car[__p0]);
}

function def_prim (__p0, __p1, __p2)
{
	__p2 = string_to_symbol(__p0);
	value[__p2] = string_to_symbol(sprintf("#<Primitive %s>",__p0));
	if ((__p1 != ""))
		num_params[value[__p2]] = __p1;
	return value[__p2];
}

function is_symbol (__p0)
{
	return ((__p0 % 4) == 2);
}

function is_number (__p0)
{
	return ((__p0 % 4) == 0);
}

function read (__p0, __p1)
{
	skip_blanks();
	if ((token == eof))
		if (__p0)
			error("Unexpected EOF");
		else
			return THE_EOF_OBJECT;
	if ((token == "("))
	{
		advance();
		__p1 = NIL;
		for (; ; )
		{
			skip_blanks();
			if ((token == "."))
			{
				advance();
				after_dot = read(1);
				skip_blanks();
				if ((token != ")"))
					error("')' expected");
				advance();
				return nreverse(__p1,after_dot);
			}
			else
				if ((token == ")"))
				{
					advance();
					return nreverse(__p1,NIL);
				}
				else
				{
					protect(__p1);
					__p1 = cons(read(1),__p1);
					unprotect();
				}
		}
	}
	else
		if ((token == "'"))
		{
			advance();
			return cons(QUOTE,cons(read(1),NIL));
		}
		else
			if ((token ~ /^-?[0-9]+$/))
			{
				__p1 = make_number(token);
				advance();
				return __p1;
			}
			else
			{
				__p1 = string_to_symbol(token);
				advance();
				return __p1;
			}
}

function protect (__p0)
{
	protected[++(protected_ptr)] = __p0;
}

function mark (__p0)
{
	while ((is_pair(__p0) && (!((__p0 in marks)))))
	{
		marks[__p0] = 1;
		mark(car[__p0]);
		__p0 = cdr[__p0];
	}
}

function write_expr (__p0)
{
	if (is_atom(__p0))
	{
		if ((!(is_symbol(__p0))))
			printf ("%d",numeric_value(__p0));
		else
		{
			if ((!((__p0 in printname))))
				error((("BUG: "   __p0)   " has no printname"));
			printf ("%s",printname[__p0]);
		}
	}
	else
	{
		printf "(";
		write_expr(car[__p0]);
		for (__p0 = cdr[__p0]; is_pair(__p0); __p0 = cdr[__p0])
		{
			printf " ";
			write_expr(car[__p0]);
		}
		if ((__p0 != NIL))
		{
			printf " . ";
			write_expr(__p0);
		}
		printf ")";
	}
}

function make_number (__p0)
{
	return (__p0 * 4);
}

function print_expr (__p0)
{
	write_expr(__p0);
	print "";
}

function progn (__p0)
{
	for (; (cdr[__p0] != NIL); __p0 = cdr[__p0])
		eval(car[__p0]);
	return eval(car[__p0]);
}

function string_to_symbol (__p0)
{
	if ((__p0 in intern))
		return intern[__p0];
	symbol_ptr += 4;
	intern[__p0] = symbol_ptr;
	printname[symbol_ptr] = __p0;
	return symbol_ptr;
}

function cons (__p0, __p1)
{
	while ((pair_ptr in marks))
	{
		delete marks[pair_ptr];
		pair_ptr += 4;
	}
	if ((pair_ptr == pair_limit))
		gc(__p0,__p1);
	car[pair_ptr] = __p0;
	cdr[pair_ptr] = __p1;
	pair_ptr += 4;
	return (pair_ptr - 4);
}

function listify_args (__p0, __p1)
{
	__p1 = NIL;
	for (__p0 = (stack_ptr - 1); (frame_ptr <= __p0); --(__p0))
		__p1 = cons(stack[__p0],__p1);
	return __p1;
}

function numeric_value (__p0)
{
	if (((__p0 % 4) != 0))
		error("Not a number");
	return (__p0 / 4);
}

function skip_blanks ()
{
	while ((token ~ /^[ 	]*$/))
		advance();
}

function apply (__p0)
{
	if (profiling)
		++(call_count[__p0]);
	if ((car[__p0] == LAMBDA))
	{
		extend_env(car[cdr[__p0]]);
		result = progn(cdr[cdr[__p0]]);
		unwind_env(car[cdr[__p0]]);
		return result;
	}
	if (((__p0 in num_params) && (num_params[__p0] != (stack_ptr - frame_ptr))))
		error(("Wrong number of arguments to "   printname[cdr[__p0]]));
	if ((__p0 == CAR))
		return car[is(a_pair,stack[frame_ptr])];
	if ((__p0 == CDR))
		return cdr[is(a_pair,stack[frame_ptr])];
	if ((__p0 == CONS))
		return cons(stack[frame_ptr],stack[(frame_ptr + 1)]);
	if ((__p0 == NULL))
		return ((stack[frame_ptr] == NIL))?T:NIL;
	if ((__p0 == EQ))
		return ((stack[frame_ptr] == stack[(frame_ptr + 1)]))?T:NIL;
	if ((__p0 == ATOMP))
		return (is_atom(stack[frame_ptr]))?T:NIL;
	if ((__p0 == ADD))
		return (is(a_number,stack[frame_ptr]) + is(a_number,stack[(frame_ptr + 1)]));
	if ((__p0 == SUB))
		return (is(a_number,stack[frame_ptr]) - is(a_number,stack[(frame_ptr + 1)]));
	if ((__p0 == MUL))
		return make_number((numeric_value(stack[frame_ptr]) * numeric_value(stack[(frame_ptr + 1)])));
	if ((__p0 == DIV))
		return make_number(int((numeric_value(stack[frame_ptr]) / numeric_value(stack[(frame_ptr + 1)]))));
	if ((__p0 == MOD))
		return make_number((numeric_value(stack[frame_ptr]) % numeric_value(stack[(frame_ptr + 1)])));
	if ((__p0 == LT))
		return (((stack[frame_ptr] + 0) < (stack[(frame_ptr + 1)] + 0)))?T:NIL;
	if ((__p0 == GET))
		return (((stack[frame_ptr],stack[(frame_ptr + 1)]) in property))?property[stack[frame_ptr],stack[(frame_ptr + 1)]]:NIL;
	if ((__p0 == PUT))
		return property[stack[frame_ptr],stack[(frame_ptr + 1)]] = stack[(frame_ptr + 2)];
	if ((__p0 == CADR))
		return car[is(a_pair,cdr[is(a_pair,stack[frame_ptr])])];
	if ((__p0 == CDDR))
		return cdr[is(a_pair,cdr[is(a_pair,stack[frame_ptr])])];
	if ((__p0 == LIST))
		return listify_args();
	if ((__p0 == SYMBOLP))
		return (is_symbol(stack[frame_ptr]))?T:NIL;
	if ((__p0 == PAIRP))
		return (is_pair(stack[frame_ptr]))?T:NIL;
	if ((__p0 == NUMBERP))
		return (is_number(stack[frame_ptr]))?T:NIL;
	if ((__p0 == SETCAR))
		return car[is(a_pair,stack[frame_ptr])] = stack[(frame_ptr + 1)];
	if ((__p0 == SETCDR))
		return cdr[is(a_pair,stack[frame_ptr])] = stack[(frame_ptr + 1)];
	if ((__p0 == APPLY))
		return do_apply(stack[frame_ptr],stack[(frame_ptr + 1)]);
	if ((__p0 == EVAL))
		return eval(stack[frame_ptr]);
	if ((__p0 == NREV))
		return nreverse(stack[frame_ptr],NIL);
	if ((__p0 == WRITE))
	{
		write_expr(stack[frame_ptr]);
		printf " ";
		return NIL;
	}
	if ((__p0 == NEWLINE))
	{
		printf "\n";
		return NIL;
	}
	if ((__p0 == READ))
		return read();
	if ((__p0 == RANDOM))
		return make_number(int((rand() * numeric_value(stack[frame_ptr]))));
	if ((__p0 == GENSYM))
		return string_to_symbol(("#G"   ++(gensym_counter)));
	if ((__p0 == ERROR))
	{
		printf "Error!\n";
		print_expr(listify_args());
		exit 1;
	}
	error("Unknown procedure type");
}

function error (__p0)
{
	print ("ERROR: "   __p0) > "/dev/stderr";
	exit 1;
}

function gc (__p0, __p1, __p2, __p3)
{
	if (loud_gc)
		printf "\nGC..." > "/dev/stderr";
	mark(__p0);
	mark(__p1);
	for (__p2 in protected)
		mark(protected[__p2]);
	for (__p2 in stack)
		mark(stack[__p2]);
	for (__p2 in value)
		mark(value[__p2]);
	for (__p2 in property)
	{
		__p3 = index(SUBSEP,__p2);
		mark(substr(__p2,1,(__p3 - 1)));
		mark(substr(__p2,(__p3 + 1)));
		mark(property[__p2]);
	}
	pair_ptr = a_pair;
	while ((pair_ptr in marks))
	{
		delete marks[pair_ptr];
		pair_ptr += 4;
	}
	if ((pair_ptr == pair_limit))
	{
		if (loud_gc)
			printf "Expanding heap..." > "/dev/stderr";
		pair_limit += (4 * heap_increment);
	}
}

function extend_env (__p0, __p1, __p2)
{
	for (__p1 = frame_ptr; (__p0 != NIL); __p0 = cdr[__p0])
	{
		if ((__p1 == stack_ptr))
			error("Too many arguments to procedure");
		__p2 = value[car[__p0]];
		value[car[__p0]] = stack[__p1];
		stack[__p1] = __p2;
		++(__p1);
	}
	if ((__p1 != stack_ptr))
		error("Not enough arguments to procedure");
}

function is_atom (__p0)
{
	return ((__p0 % 4) != 1);
}

function is_pair (__p0)
{
	return ((__p0 % 4) == 1);
}

function eval (__p0, __p1)
{
	if (is_atom(__p0))
		if (is_symbol(__p0))
		{
			if ((!((__p0 in value))))
				error(("Unbound variable: "   printname[__p0]));
			return value[__p0];
		}
		else
			return __p0;
	op = car[__p0];
	if ((!((op in is_special))))
	{
		__p1 = frame_ptr;
		frame_ptr = stack_ptr;
		eval_rands(cdr[__p0]);
		protect(proc = eval(car[__p0]));
		result = apply(proc);
		unprotect();
		stack_ptr = frame_ptr;
		frame_ptr = __p1;
		return result;
	}
	if ((op == QUOTE))
		return car[cdr[__p0]];
	if ((op == LAMBDA))
		return __p0;
	if ((op == IF))
		return ((eval(car[cdr[__p0]]) != NIL))?eval(car[cdr[cdr[__p0]]]):eval(car[cdr[cdr[cdr[__p0]]]]);
	if ((op == PROGN))
		return progn(cdr[__p0]);
	if ((op == SETQ))
	{
		if ((!((car[cdr[__p0]] in value))))
			error(("Unbound variable: "   printname[car[cdr[__p0]]]));
		return value[car[cdr[__p0]]] = eval(car[cdr[cdr[__p0]]]);
	}
	if ((op == WHILE))
	{
		while ((eval(car[cdr[__p0]]) != NIL))
			progn(cdr[cdr[__p0]]);
		return NIL;
	}
	if ((op == DEFINE))
	{
		value[car[cdr[__p0]]] = eval(car[cdr[cdr[__p0]]]);
		return car[cdr[__p0]];
	}
	error("BUG: Unknown special form");
}

function is (__p0, __p1)
{
	if (((__p1 % 4) != __p0))
		error(((("Expected a "   type_name[__p0])   ", not a ")   type_name[(__p1 % 4)]));
	return __p1;
}

function unwind_env (__p0, __p1)
{
	for (__p1 = frame_ptr; (__p0 != NIL); __p0 = cdr[__p0])
	{
		if ((stack[__p1] == ""))
			delete value[car[__p0]];
		else
			value[car[__p0]] = stack[__p1];
		++(__p1);
	}
}

function nreverse (__p0, __p1, __p2)
{
	while (is_pair(__p0))
	{
		__p2 = cdr[__p0];
		cdr[__p0] = __p1;
		__p1 = __p0;
		__p0 = __p2;
	}
	if ((__p0 != NIL))
		error("Not a proper list - reverse!");
	return __p1;
}

function advance ()
{
	if ((token == eof))
		return eof;
	if ((token == ""))
	{
		if (((getline line) <= 0))
		{
			token = eof;
			return;
		}
	}
	if (((match(line,"^[()'.]") || match(line,"^[_A-Za-z0-9=!@$%&*<>?+\\-*/:]+")) || match(line,"^[ \\t]+")))
	{
		token = substr(line,RSTART,RLENGTH);
		line = substr(line,(RLENGTH + 1));
	}
	else
		if (((line == "") || (substr(line,1,1) == ";")))
			token = "";
		else
			error(("Lexical error starting at "   line));
}

function do_apply (__p0, __p1, __p2)
{
	__p2 = frame_ptr;
	frame_ptr = stack_ptr;
	for (; is_pair(__p1); __p1 = cdr[__p1])
		stack[(stack_ptr)++] = car[__p1];
	if ((__p1 != NIL))
		error("Bad argument to APPLY: not a proper list");
	result = apply(__p0);
	stack_ptr = frame_ptr;
	frame_ptr = __p2;
	return result;
}

function unprotect ()
{
	--(protected_ptr);
}

BEGIN {
	a_number = 0;
	pair_ptr = a_pair = 1;
	symbol_ptr = a_symbol = 2;
	type_name[a_number] = "number";
	type_name[a_pair] = "pair";
	type_name[a_symbol] = "symbol";
}

BEGIN {
	srand();
	frame_ptr = stack_ptr = 0;
	if ((heap_increment == ""))
		heap_increment = 1500;
	pair_limit = (a_pair + (4 * heap_increment));
	NIL = string_to_symbol("nil");
	T = string_to_symbol("t");
	value[NIL] = NIL;
	value[T] = T;
	car[NIL] = cdr[NIL] = NIL;
	THE_EOF_OBJECT = string_to_symbol("#eof");
	value[string_to_symbol("the-eof-object")] = THE_EOF_OBJECT;
	eof = "(eof)";
	QUOTE = string_to_symbol("quote");
	is_special[QUOTE] = 1;
	LAMBDA = string_to_symbol("lambda");
	is_special[LAMBDA] = 1;
	IF = string_to_symbol("if");
	is_special[IF] = 1;
	SETQ = string_to_symbol("set!");
	is_special[SETQ] = 1;
	DEFINE = string_to_symbol("define");
	is_special[DEFINE] = 1;
	PROGN = string_to_symbol("begin");
	is_special[PROGN] = 1;
	WHILE = string_to_symbol("while");
	is_special[WHILE] = 1;
	EQ = def_prim("eq?",2);
	NULL = def_prim("null?",1);
	CAR = def_prim("car",1);
	CDR = def_prim("cdr",1);
	CADR = def_prim("cadr",1);
	CDDR = def_prim("cddr",1);
	CONS = def_prim("cons",2);
	LIST = def_prim("list");
	EVAL = def_prim("eval",1);
	APPLY = def_prim("apply",2);
	READ = def_prim("read",0);
	WRITE = def_prim("write",1);
	NEWLINE = def_prim("newline",0);
	ADD = def_prim("+",2);
	SUB = def_prim("-",2);
	MUL = def_prim("*",2);
	DIV = def_prim("quotient",2);
	MOD = def_prim("remainder",2);
	LT = def_prim("<",2);
	GET = def_prim("get",2);
	PUT = def_prim("put",3);
	ATOMP = def_prim("atom?",1);
	PAIRP = def_prim("pair?",1);
	SYMBOLP = def_prim("symbol?",1);
	NUMBERP = def_prim("number?",1);
	SETCAR = def_prim("set-car!",2);
	SETCDR = def_prim("set-cdr!",2);
	NREV = def_prim("reverse!",1);
	GENSYM = def_prim("gensym",0);
	RANDOM = def_prim("random",1);
	ERROR = def_prim("error");
	DRIVER = string_to_symbol("top-level-driver");
}

BEGIN {
	for (; ; )
	{
		if (((DRIVER in value) && (value[DRIVER] != NIL)))
			apply(value[DRIVER]);
		else
		{
			expr = read();
			if ((expr == THE_EOF_OBJECT))
				break;
			protect(expr);
			print_expr(eval(expr));
			unprotect();
		}
	}
	if (profiling)
		for (proc in call_count)
		{
			printf ("%5d ",call_count[proc]);
			print_expr(proc);
		}
}

--------------------------------------------------------------------------------
[CMD]  qseawk  -d- -f lisp/awklisp lisp/startup lisp/scmhelp.lsp lisp/tail.lsp </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function eval_rands (__p0)
{
	for (; (__p0 != NIL); __p0 = cdr[__p0])
		stack[(stack_ptr)++] = eval(car[__p0]);
}

function def_prim (__p0, __p1, __p2)
{
	__p2 = string_to_symbol(__p0);
	value[__p2] = string_to_symbol(sprintf("#<Primitive %s>",__p0));
	if ((__p1 != ""))
		num_params[value[__p2]] = __p1;
	return value[__p2];
}

function is_symbol (__p0)
{
	return ((__p0 % 4) == 2);
}

function is_number (__p0)
{
	return ((__p0 % 4) == 0);
}

function read (__p0, __p1)
{
	skip_blanks();
	if ((token == eof))
		if (__p0)
			error("Unexpected EOF");
		else
			return THE_EOF_OBJECT;
	if ((token == "("))
	{
		advance();
		__p1 = NIL;
		for (; ; )
		{
			skip_blanks();
			if ((token == "."))
			{
				advance();
				after_dot = read(1);
				skip_blanks();
				if ((token != ")"))
					error("')' expected");
				advance();
				return nreverse(__p1,after_dot);
			}
			else
				if ((token == ")"))
				{
					advance();
					return nreverse(__p1,NIL);
				}
				else
				{
					protect(__p1);
					__p1 = cons(read(1),__p1);
					unprotect();
				}
		}
	}
	else
		if ((token == "'"))
		{
			advance();
			return cons(QUOTE,cons(read(1),NIL));
		}
		else
			if ((token ~ /^-?[0-9]+$/))
			{
				__p1 = make_number(token);
				advance();
				return __p1;
			}
			else
			{
				__p1 = string_to_symbol(token);
				advance();
				return __p1;
			}
}

function protect (__p0)
{
	protected[++(protected_ptr)] = __p0;
}

function mark (__p0)
{
	while ((is_pair(__p0) && (!((__p0 in marks)))))
	{
		marks[__p0] = 1;
		mark(car[__p0]);
		__p0 = cdr[__p0];
	}
}

function write_expr (__p0)
{
	if (is_atom(__p0))
	{
		if ((!(is_symbol(__p0))))
			printf ("%d",numeric_value(__p0));
		else
		{
			if ((!((__p0 in printname))))
				error((("BUG: "   __p0)   " has no printname"));
			printf ("%s",printname[__p0]);
		}
	}
	else
	{
		printf "(";
		write_expr(car[__p0]);
		for (__p0 = cdr[__p0]; is_pair(__p0); __p0 = cdr[__p0])
		{
			printf " ";
			write_expr(car[__p0]);
		}
		if ((__p0 != NIL))
		{
			printf " . ";
			write_expr(__p0);
		}
		printf ")";
	}
}

function make_number (__p0)
{
	return (__p0 * 4);
}

function print_expr (__p0)
{
	write_expr(__p0);
	print "";
}

function progn (__p0)
{
	for (; (cdr[__p0] != NIL); __p0 = cdr[__p0])
		eval(car[__p0]);
	return eval(car[__p0]);
}

function string_to_symbol (__p0)
{
	if ((__p0 in intern))
		return intern[__p0];
	symbol_ptr += 4;
	intern[__p0] = symbol_ptr;
	printname[symbol_ptr] = __p0;
	return symbol_ptr;
}

function cons (__p0, __p1)
{
	while ((pair_ptr in marks))
	{
		delete marks[pair_ptr];
		pair_ptr += 4;
	}
	if ((pair_ptr == pair_limit))
		gc(__p0,__p1);
	car[pair_ptr] = __p0;
	cdr[pair_ptr] = __p1;
	pair_ptr += 4;
	return (pair_ptr - 4);
}

function listify_args (__p0, __p1)
{
	__p1 = NIL;
	for (__p0 = (stack_ptr - 1); (frame_ptr <= __p0); --(__p0))
		__p1 = cons(stack[__p0],__p1);
	return __p1;
}

function numeric_value (__p0)
{
	if (((__p0 % 4) != 0))
		error("Not a number");
	return (__p0 / 4);
}

function skip_blanks ()
{
	while ((token ~ /^[ 	]*$/))
		advance();
}

function apply (__p0)
{
	if (profiling)
		++(call_count[__p0]);
	if ((car[__p0] == LAMBDA))
	{
		extend_env(car[cdr[__p0]]);
		result = progn(cdr[cdr[__p0]]);
		unwind_env(car[cdr[__p0]]);
		return result;
	}
	if (((__p0 in num_params) && (num_params[__p0] != (stack_ptr - frame_ptr))))
		error(("Wrong number of arguments to "   printname[cdr[__p0]]));
	if ((__p0 == CAR))
		return car[is(a_pair,stack[frame_ptr])];
	if ((__p0 == CDR))
		return cdr[is(a_pair,stack[frame_ptr])];
	if ((__p0 == CONS))
		return cons(stack[frame_ptr],stack[(frame_ptr + 1)]);
	if ((__p0 == NULL))
		return ((stack[frame_ptr] == NIL))?T:NIL;
	if ((__p0 == EQ))
		return ((stack[frame_ptr] == stack[(frame_ptr + 1)]))?T:NIL;
	if ((__p0 == ATOMP))
		return (is_atom(stack[frame_ptr]))?T:NIL;
	if ((__p0 == ADD))
		return (is(a_number,stack[frame_ptr]) + is(a_number,stack[(frame_ptr + 1)]));
	if ((__p0 == SUB))
		return (is(a_number,stack[frame_ptr]) - is(a_number,stack[(frame_ptr + 1)]));
	if ((__p0 == MUL))
		return make_number((numeric_value(stack[frame_ptr]) * numeric_value(stack[(frame_ptr + 1)])));
	if ((__p0 == DIV))
		return make_number(int((numeric_value(stack[frame_ptr]) / numeric_value(stack[(frame_ptr + 1)]))));
	if ((__p0 == MOD))
		return make_number((numeric_value(stack[frame_ptr]) % numeric_value(stack[(frame_ptr + 1)])));
	if ((__p0 == LT))
		return (((stack[frame_ptr] + 0) < (stack[(frame_ptr + 1)] + 0)))?T:NIL;
	if ((__p0 == GET))
		return (((stack[frame_ptr],stack[(frame_ptr + 1)]) in property))?property[stack[frame_ptr],stack[(frame_ptr + 1)]]:NIL;
	if ((__p0 == PUT))
		return property[stack[frame_ptr],stack[(frame_ptr + 1)]] = stack[(frame_ptr + 2)];
	if ((__p0 == CADR))
		return car[is(a_pair,cdr[is(a_pair,stack[frame_ptr])])];
	if ((__p0 == CDDR))
		return cdr[is(a_pair,cdr[is(a_pair,stack[frame_ptr])])];
	if ((__p0 == LIST))
		return listify_args();
	if ((__p0 == SYMBOLP))
		return (is_symbol(stack[frame_ptr]))?T:NIL;
	if ((__p0 == PAIRP))
		return (is_pair(stack[frame_ptr]))?T:NIL;
	if ((__p0 == NUMBERP))
		return (is_number(stack[frame_ptr]))?T:NIL;
	if ((__p0 == SETCAR))
		return car[is(a_pair,stack[frame_ptr])] = stack[(frame_ptr + 1)];
	if ((__p0 == SETCDR))
		return cdr[is(a_pair,stack[frame_ptr])] = stack[(frame_ptr + 1)];
	if ((__p0 == APPLY))
		return do_apply(stack[frame_ptr],stack[(frame_ptr + 1)]);
	if ((__p0 == EVAL))
		return eval(stack[frame_ptr]);
	if ((__p0 == NREV))
		return nreverse(stack[frame_ptr],NIL);
	if ((__p0 == WRITE))
	{
		write_expr(stack[frame_ptr]);
		printf " ";
		return NIL;
	}
	if ((__p0 == NEWLINE))
	{
		printf "\n";
		return NIL;
	}
	if ((__p0 == READ))
		return read();
	if ((__p0 == RANDOM))
		return make_number(int((rand() * numeric_value(stack[frame_ptr]))));
	if ((__p0 == GENSYM))
		return string_to_symbol(("#G"   ++(gensym_counter)));
	if ((__p0 == ERROR))
	{
		printf "Error!\n";
		print_expr(listify_args());
		exit 1;
	}
	error("Unknown procedure type");
}

function error (__p0)
{
	print ("ERROR: "   __p0) > "/dev/stderr";
	exit 1;
}

function gc (__p0, __p1, __p2, __p3)
{
	if (loud_gc)
		printf "\nGC..." > "/dev/stderr";
	mark(__p0);
	mark(__p1);
	for (__p2 in protected)
		mark(protected[__p2]);
	for (__p2 in stack)
		mark(stack[__p2]);
	for (__p2 in value)
		mark(value[__p2]);
	for (__p2 in property)
	{
		__p3 = index(SUBSEP,__p2);
		mark(substr(__p2,1,(__p3 - 1)));
		mark(substr(__p2,(__p3 + 1)));
		mark(property[__p2]);
	}
	pair_ptr = a_pair;
	while ((pair_ptr in marks))
	{
		delete marks[pair_ptr];
		pair_ptr += 4;
	}
	if ((pair_ptr == pair_limit))
	{
		if (loud_gc)
			printf "Expanding heap..." > "/dev/stderr";
		pair_limit += (4 * heap_increment);
	}
}

function extend_env (__p0, __p1, __p2)
{
	for (__p1 = frame_ptr; (__p0 != NIL); __p0 = cdr[__p0])
	{
		if ((__p1 == stack_ptr))
			error("Too many arguments to procedure");
		__p2 = value[car[__p0]];
		value[car[__p0]] = stack[__p1];
		stack[__p1] = __p2;
		++(__p1);
	}
	if ((__p1 != stack_ptr))
		error("Not enough arguments to procedure");
}

function is_atom (__p0)
{
	return ((__p0 % 4) != 1);
}

function is_pair (__p0)
{
	return ((__p0 % 4) == 1);
}

function eval (__p0, __p1)
{
	if (is_atom(__p0))
		if (is_symbol(__p0))
		{
			if ((!((__p0 in value))))
				error(("Unbound variable: "   printname[__p0]));
			return value[__p0];
		}
		else
			return __p0;
	op = car[__p0];
	if ((!((op in is_special))))
	{
		__p1 = frame_ptr;
		frame_ptr = stack_ptr;
		eval_rands(cdr[__p0]);
		protect(proc = eval(car[__p0]));
		result = apply(proc);
		unprotect();
		stack_ptr = frame_ptr;
		frame_ptr = __p1;
		return result;
	}
	if ((op == QUOTE))
		return car[cdr[__p0]];
	if ((op == LAMBDA))
		return __p0;
	if ((op == IF))
		return ((eval(car[cdr[__p0]]) != NIL))?eval(car[cdr[cdr[__p0]]]):eval(car[cdr[cdr[cdr[__p0]]]]);
	if ((op == PROGN))
		return progn(cdr[__p0]);
	if ((op == SETQ))
	{
		if ((!((car[cdr[__p0]] in value))))
			error(("Unbound variable: "   printname[car[cdr[__p0]]]));
		return value[car[cdr[__p0]]] = eval(car[cdr[cdr[__p0]]]);
	}
	if ((op == WHILE))
	{
		while ((eval(car[cdr[__p0]]) != NIL))
			progn(cdr[cdr[__p0]]);
		return NIL;
	}
	if ((op == DEFINE))
	{
		value[car[cdr[__p0]]] = eval(car[cdr[cdr[__p0]]]);
		return car[cdr[__p0]];
	}
	error("BUG: Unknown special form");
}

function is (__p0, __p1)
{
	if (((__p1 % 4) != __p0))
		error(((("Expected a "   type_name[__p0])   ", not a ")   type_name[(__p1 % 4)]));
	return __p1;
}

function unwind_env (__p0, __p1)
{
	for (__p1 = frame_ptr; (__p0 != NIL); __p0 = cdr[__p0])
	{
		if ((stack[__p1] == ""))
			delete value[car[__p0]];
		else
			value[car[__p0]] = stack[__p1];
		++(__p1);
	}
}

function nreverse (__p0, __p1, __p2)
{
	while (is_pair(__p0))
	{
		__p2 = cdr[__p0];
		cdr[__p0] = __p1;
		__p1 = __p0;
		__p0 = __p2;
	}
	if ((__p0 != NIL))
		error("Not a proper list - reverse!");
	return __p1;
}

function advance ()
{
	if ((token == eof))
		return eof;
	if ((token == ""))
	{
		if (((getline line) <= 0))
		{
			token = eof;
			return;
		}
	}
	if (((match(line,"^[()'.]") || match(line,"^[_A-Za-z0-9=!@$%&*<>?+\\-*/:]+")) || match(line,"^[ \\t]+")))
	{
		token = substr(line,RSTART,RLENGTH);
		line = substr(line,(RLENGTH + 1));
	}
	else
		if (((line == "") || (substr(line,1,1) == ";")))
			token = "";
		else
			error(("Lexical error starting at "   line));
}

function do_apply (__p0, __p1, __p2)
{
	__p2 = frame_ptr;
	frame_ptr = stack_ptr;
	for (; is_pair(__p1); __p1 = cdr[__p1])
		stack[(stack_ptr)++] = car[__p1];
	if ((__p1 != NIL))
		error("Bad argument to APPLY: not a proper list");
	result = apply(__p0);
	stack_ptr = frame_ptr;
	frame_ptr = __p2;
	return result;
}

function unprotect ()
{
	--(protected_ptr);
}

BEGIN {
	a_number = 0;
	pair_ptr = a_pair = 1;
	symbol_ptr = a_symbol = 2;
	type_name[a_number] = "number";
	type_name[a_pair] = "pair";
	type_name[a_symbol] = "symbol";
}

BEGIN {
	srand();
	frame_ptr = stack_ptr = 0;
	if ((heap_increment == ""))
		heap_increment = 1500;
	pair_limit = (a_pair + (4 * heap_increment));
	NIL = string_to_symbol("nil");
	T = string_to_symbol("t");
	value[NIL] = NIL;
	value[T] = T;
	car[NIL] = cdr[NIL] = NIL;
	THE_EOF_OBJECT = string_to_symbol("#eof");
	value[string_to_symbol("the-eof-object")] = THE_EOF_OBJECT;
	eof = "(eof)";
	QUOTE = string_to_symbol("quote");
	is_special[QUOTE] = 1;
	LAMBDA = string_to_symbol("lambda");
	is_special[LAMBDA] = 1;
	IF = string_to_symbol("if");
	is_special[IF] = 1;
	SETQ = string_to_symbol("set!");
	is_special[SETQ] = 1;
	DEFINE = string_to_symbol("define");
	is_special[DEFINE] = 1;
	PROGN = string_to_symbol("begin");
	is_special[PROGN] = 1;
	WHILE = string_to_symbol("while");
	is_special[WHILE] = 1;
	EQ = def_prim("eq?",2);
	NULL = def_prim("null?",1);
	CAR = def_prim("car",1);
	CDR = def_prim("cdr",1);
	CADR = def_prim("cadr",1);
	CDDR = def_prim("cddr",1);
	CONS = def_prim("cons",2);
	LIST = def_prim("list");
	EVAL = def_prim("eval",1);
	APPLY = def_prim("apply",2);
	READ = def_prim("read",0);
	WRITE = def_prim("write",1);
	NEWLINE = def_prim("newline",0);
	ADD = def_prim("+",2);
	SUB = def_prim("-",2);
	MUL = def_prim("*",2);
	DIV = def_prim("quotient",2);
	MOD = def_prim("remainder",2);
	LT = def_prim("<",2);
	GET = def_prim("get",2);
	PUT = def_prim("put",3);
	ATOMP = def_prim("atom?",1);
	PAIRP = def_prim("pair?",1);
	SYMBOLP = def_prim("symbol?",1);
	NUMBERP = def_prim("number?",1);
	SETCAR = def_prim("set-car!",2);
	SETCDR = def_prim("set-cdr!",2);
	NREV = def_prim("reverse!",1);
	GENSYM = def_prim("gensym",0);
	RANDOM = def_prim("random",1);
	ERROR = def_prim("error");
	DRIVER = string_to_symbol("top-level-driver");
}

BEGIN {
	for (; ; )
	{
		if (((DRIVER in value) && (value[DRIVER] != NIL)))
			apply(value[DRIVER]);
		else
		{
			expr = read();
			if ((expr == THE_EOF_OBJECT))
				break;
			protect(expr);
			print_expr(eval(expr));
			unprotect();
		}
	}
	if (profiling)
		for (proc in call_count)
		{
			printf ("%5d ",call_count[proc]);
			print_expr(proc);
		}
}

--------------------------------------------------------------------------------
[CMD]  qseawk  -d- -f lisp/awklisp lisp/startup lisp/scmhelp.lsp lisp/scheme.lsp </dev/stdin 2>&1 
--------------------------------------------------------------------------------
function eval_rands (__p0)
{
	for (; (__p0 != NIL); __p0 = cdr[__p0])
		stack[(stack_ptr)++] = eval(car[__p0]);
}

function def_prim (__p0, __p1, __p2)
{
	__p2 = string_to_symbol(__p0);
	value[__p2] = string_to_symbol(sprintf("#<Primitive %s>",__p0));
	if ((__p1 != ""))
		num_params[value[__p2]] = __p1;
	return value[__p2];
}

function is_symbol (__p0)
{
	return ((__p0 % 4) == 2);
}

function is_number (__p0)
{
	return ((__p0 % 4) == 0);
}

function read (__p0, __p1)
{
	skip_blanks();
	if ((token == eof))
		if (__p0)
			error("Unexpected EOF");
		else
			return THE_EOF_OBJECT;
	if ((token == "("))
	{
		advance();
		__p1 = NIL;
		for (; ; )
		{
			skip_blanks();
			if ((token == "."))
			{
				advance();
				after_dot = read(1);
				skip_blanks();
				if ((token != ")"))
					error("')' expected");
				advance();
				return nreverse(__p1,after_dot);
			}
			else
				if ((token == ")"))
				{
					advance();
					return nreverse(__p1,NIL);
				}
				else
				{
					protect(__p1);
					__p1 = cons(read(1),__p1);
					unprotect();
				}
		}
	}
	else
		if ((token == "'"))
		{
			advance();
			return cons(QUOTE,cons(read(1),NIL));
		}
		else
			if ((token ~ /^-?[0-9]+$/))
			{
				__p1 = make_number(token);
				advance();
				return __p1;
			}
			else
			{
				__p1 = string_to_symbol(token);
				advance();
				return __p1;
			}
}

function protect (__p0)
{
	protected[++(protected_ptr)] = __p0;
}

function mark (__p0)
{
	while ((is_pair(__p0) && (!((__p0 in marks)))))
	{
		marks[__p0] = 1;
		mark(car[__p0]);
		__p0 = cdr[__p0];
	}
}

function write_expr (__p0)
{
	if (is_atom(__p0))
	{
		if ((!(is_symbol(__p0))))
			printf ("%d",numeric_value(__p0));
		else
		{
			if ((!((__p0 in printname))))
				error((("BUG: "   __p0)   " has no printname"));
			printf ("%s",printname[__p0]);
		}
	}
	else
	{
		printf "(";
		write_expr(car[__p0]);
		for (__p0 = cdr[__p0]; is_pair(__p0); __p0 = cdr[__p0])
		{
			printf " ";
			write_expr(car[__p0]);
		}
		if ((__p0 != NIL))
		{
			printf " . ";
			write_expr(__p0);
		}
		printf ")";
	}
}

function make_number (__p0)
{
	return (__p0 * 4);
}

function print_expr (__p0)
{
	write_expr(__p0);
	print "";
}

function progn (__p0)
{
	for (; (cdr[__p0] != NIL); __p0 = cdr[__p0])
		eval(car[__p0]);
	return eval(car[__p0]);
}

function string_to_symbol (__p0)
{
	if ((__p0 in intern))
		return intern[__p0];
	symbol_ptr += 4;
	intern[__p0] = symbol_ptr;
	printname[symbol_ptr] = __p0;
	return symbol_ptr;
}

function cons (__p0, __p1)
{
	while ((pair_ptr in marks))
	{
		delete marks[pair_ptr];
		pair_ptr += 4;
	}
	if ((pair_ptr == pair_limit))
		gc(__p0,__p1);
	car[pair_ptr] = __p0;
	cdr[pair_ptr] = __p1;
	pair_ptr += 4;
	return (pair_ptr - 4);
}

function listify_args (__p0, __p1)
{
	__p1 = NIL;
	for (__p0 = (stack_ptr - 1); (frame_ptr <= __p0); --(__p0))
		__p1 = cons(stack[__p0],__p1);
	return __p1;
}

function numeric_value (__p0)
{
	if (((__p0 % 4) != 0))
		error("Not a number");
	return (__p0 / 4);
}

function skip_blanks ()
{
	while ((token ~ /^[ 	]*$/))
		advance();
}

function apply (__p0)
{
	if (profiling)
		++(call_count[__p0]);
	if ((car[__p0] == LAMBDA))
	{
		extend_env(car[cdr[__p0]]);
		result = progn(cdr[cdr[__p0]]);
		unwind_env(car[cdr[__p0]]);
		return result;
	}
	if (((__p0 in num_params) && (num_params[__p0] != (stack_ptr - frame_ptr))))
		error(("Wrong number of arguments to "   printname[cdr[__p0]]));
	if ((__p0 == CAR))
		return car[is(a_pair,stack[frame_ptr])];
	if ((__p0 == CDR))
		return cdr[is(a_pair,stack[frame_ptr])];
	if ((__p0 == CONS))
		return cons(stack[frame_ptr],stack[(frame_ptr + 1)]);
	if ((__p0 == NULL))
		return ((stack[frame_ptr] == NIL))?T:NIL;
	if ((__p0 == EQ))
		return ((stack[frame_ptr] == stack[(frame_ptr + 1)]))?T:NIL;
	if ((__p0 == ATOMP))
		return (is_atom(stack[frame_ptr]))?T:NIL;
	if ((__p0 == ADD))
		return (is(a_number,stack[frame_ptr]) + is(a_number,stack[(frame_ptr + 1)]));
	if ((__p0 == SUB))
		return (is(a_number,stack[frame_ptr]) - is(a_number,stack[(frame_ptr + 1)]));
	if ((__p0 == MUL))
		return make_number((numeric_value(stack[frame_ptr]) * numeric_value(stack[(frame_ptr + 1)])));
	if ((__p0 == DIV))
		return make_number(int((numeric_value(stack[frame_ptr]) / numeric_value(stack[(frame_ptr + 1)]))));
	if ((__p0 == MOD))
		return make_number((numeric_value(stack[frame_ptr]) % numeric_value(stack[(frame_ptr + 1)])));
	if ((__p0 == LT))
		return (((stack[frame_ptr] + 0) < (stack[(frame_ptr + 1)] + 0)))?T:NIL;
	if ((__p0 == GET))
		return (((stack[frame_ptr],stack[(frame_ptr + 1)]) in property))?property[stack[frame_ptr],stack[(frame_ptr + 1)]]:NIL;
	if ((__p0 == PUT))
		return property[stack[frame_ptr],stack[(frame_ptr + 1)]] = stack[(frame_ptr + 2)];
	if ((__p0 == CADR))
		return car[is(a_pair,cdr[is(a_pair,stack[frame_ptr])])];
	if ((__p0 == CDDR))
		return cdr[is(a_pair,cdr[is(a_pair,stack[frame_ptr])])];
	if ((__p0 == LIST))
		return listify_args();
	if ((__p0 == SYMBOLP))
		return (is_symbol(stack[frame_ptr]))?T:NIL;
	if ((__p0 == PAIRP))
		return (is_pair(stack[frame_ptr]))?T:NIL;
	if ((__p0 == NUMBERP))
		return (is_number(stack[frame_ptr]))?T:NIL;
	if ((__p0 == SETCAR))
		return car[is(a_pair,stack[frame_ptr])] = stack[(frame_ptr + 1)];
	if ((__p0 == SETCDR))
		return cdr[is(a_pair,stack[frame_ptr])] = stack[(frame_ptr + 1)];
	if ((__p0 == APPLY))
		return do_apply(stack[frame_ptr],stack[(frame_ptr + 1)]);
	if ((__p0 == EVAL))
		return eval(stack[frame_ptr]);
	if ((__p0 == NREV))
		return nreverse(stack[frame_ptr],NIL);
	if ((__p0 == WRITE))
	{
		write_expr(stack[frame_ptr]);
		printf " ";
		return NIL;
	}
	if ((__p0 == NEWLINE))
	{
		printf "\n";
		return NIL;
	}
	if ((__p0 == READ))
		return read();
	if ((__p0 == RANDOM))
		return make_number(int((rand() * numeric_value(stack[frame_ptr]))));
	if ((__p0 == GENSYM))
		return string_to_symbol(("#G"   ++(gensym_counter)));
	if ((__p0 == ERROR))
	{
		printf "Error!\n";
		print_expr(listify_args());
		exit 1;
	}
	error("Unknown procedure type");
}

function error (__p0)
{
	print ("ERROR: "   __p0) > "/dev/stderr";
	exit 1;
}

function gc (__p0, __p1, __p2, __p3)
{
	if (loud_gc)
		printf "\nGC..." > "/dev/stderr";
	mark(__p0);
	mark(__p1);
	for (__p2 in protected)
		mark(protected[__p2]);
	for (__p2 in stack)
		mark(stack[__p2]);
	for (__p2 in value)
		mark(value[__p2]);
	for (__p2 in property)
	{
		__p3 = index(SUBSEP,__p2);
		mark(substr(__p2,1,(__p3 - 1)));
		mark(substr(__p2,(__p3 + 1)));
		mark(property[__p2]);
	}
	pair_ptr = a_pair;
	while ((pair_ptr in marks))
	{
		delete marks[pair_ptr];
		pair_ptr += 4;
	}
	if ((pair_ptr == pair_limit))
	{
		if (loud_gc)
			printf "Expanding heap..." > "/dev/stderr";
		pair_limit += (4 * heap_increment);
	}
}

function extend_env (__p0, __p1, __p2)
{
	for (__p1 = frame_ptr; (__p0 != NIL); __p0 = cdr[__p0])
	{
		if ((__p1 == stack_ptr))
			error("Too many arguments to procedure");
		__p2 = value[car[__p0]];
		value[car[__p0]] = stack[__p1];
		stack[__p1] = __p2;
		++(__p1);
	}
	if ((__p1 != stack_ptr))
		error("Not enough arguments to procedure");
}

function is_atom (__p0)
{
	return ((__p0 % 4) != 1);
}

function is_pair (__p0)
{
	return ((__p0 % 4) == 1);
}

function eval (__p0, __p1)
{
	if (is_atom(__p0))
		if (is_symbol(__p0))
		{
			if ((!((__p0 in value))))
				error(("Unbound variable: "   printname[__p0]));
			return value[__p0];
		}
		else
			return __p0;
	op = car[__p0];
	if ((!((op in is_special))))
	{
		__p1 = frame_ptr;
		frame_ptr = stack_ptr;
		eval_rands(cdr[__p0]);
		protect(proc = eval(car[__p0]));
		result = apply(proc);
		unprotect();
		stack_ptr = frame_ptr;
		frame_ptr = __p1;
		return result;
	}
	if ((op == QUOTE))
		return car[cdr[__p0]];
	if ((op == LAMBDA))
		return __p0;
	if ((op == IF))
		return ((eval(car[cdr[__p0]]) != NIL))?eval(car[cdr[cdr[__p0]]]):eval(car[cdr[cdr[cdr[__p0]]]]);
	if ((op == PROGN))
		return progn(cdr[__p0]);
	if ((op == SETQ))
	{
		if ((!((car[cdr[__p0]] in value))))
			error(("Unbound variable: "   printname[car[cdr[__p0]]]));
		return value[car[cdr[__p0]]] = eval(car[cdr[cdr[__p0]]]);
	}
	if ((op == WHILE))
	{
		while ((eval(car[cdr[__p0]]) != NIL))
			progn(cdr[cdr[__p0]]);
		return NIL;
	}
	if ((op == DEFINE))
	{
		value[car[cdr[__p0]]] = eval(car[cdr[cdr[__p0]]]);
		return car[cdr[__p0]];
	}
	error("BUG: Unknown special form");
}

function is (__p0, __p1)
{
	if (((__p1 % 4) != __p0))
		error(((("Expected a "   type_name[__p0])   ", not a ")   type_name[(__p1 % 4)]));
	return __p1;
}

function unwind_env (__p0, __p1)
{
	for (__p1 = frame_ptr; (__p0 != NIL); __p0 = cdr[__p0])
	{
		if ((stack[__p1] == ""))
			delete value[car[__p0]];
		else
			value[car[__p0]] = stack[__p1];
		++(__p1);
	}
}

function nreverse (__p0, __p1, __p2)
{
	while (is_pair(__p0))
	{
		__p2 = cdr[__p0];
		cdr[__p0] = __p1;
		__p1 = __p0;
		__p0 = __p2;
	}
	if ((__p0 != NIL))
		error("Not a proper list - reverse!");
	return __p1;
}

function advance ()
{
	if ((token == eof))
		return eof;
	if ((token == ""))
	{
		if (((getline line) <= 0))
		{
			token = eof;
			return;
		}
	}
	if (((match(line,"^[()'.]") || match(line,"^[_A-Za-z0-9=!@$%&*<>?+\\-*/:]+")) || match(line,"^[ \\t]+")))
	{
		token = substr(line,RSTART,RLENGTH);
		line = substr(line,(RLENGTH + 1));
	}
	else
		if (((line == "") || (substr(line,1,1) == ";")))
			token = "";
		else
			error(("Lexical error starting at "   line));
}

function do_apply (__p0, __p1, __p2)
{
	__p2 = frame_ptr;
	frame_ptr = stack_ptr;
	for (; is_pair(__p1); __p1 = cdr[__p1])
		stack[(stack_ptr)++] = car[__p1];
	if ((__p1 != NIL))
		error("Bad argument to APPLY: not a proper list");
	result = apply(__p0);
	stack_ptr = frame_ptr;
	frame_ptr = __p2;
	return result;
}

function unprotect ()
{
	--(protected_ptr);
}

BEGIN {
	a_number = 0;
	pair_ptr = a_pair = 1;
	symbol_ptr = a_symbol = 2;
	type_name[a_number] = "number";
	type_name[a_pair] = "pair";
	type_name[a_symbol] = "symbol";
}

BEGIN {
	srand();
	frame_ptr = stack_ptr = 0;
	if ((heap_increment == ""))
		heap_increment = 1500;
	pair_limit = (a_pair + (4 * heap_increment));
	NIL = string_to_symbol("nil");
	T = string_to_symbol("t");
	value[NIL] = NIL;
	value[T] = T;
	car[NIL] = cdr[NIL] = NIL;
	THE_EOF_OBJECT = string_to_symbol("#eof");
	value[string_to_symbol("the-eof-object")] = THE_EOF_OBJECT;
	eof = "(eof)";
	QUOTE = string_to_symbol("quote");
	is_special[QUOTE] = 1;
	LAMBDA = string_to_symbol("lambda");
	is_special[LAMBDA] = 1;
	IF = string_to_symbol("if");
	is_special[IF] = 1;
	SETQ = string_to_symbol("set!");
	is_special[SETQ] = 1;
	DEFINE = string_to_symbol("define");
	is_special[DEFINE] = 1;
	PROGN = string_to_symbol("begin");
	is_special[PROGN] = 1;
	WHILE = string_to_symbol("while");
	is_special[WHILE] = 1;
	EQ = def_prim("eq?",2);
	NULL = def_prim("null?",1);
	CAR = def_prim("car",1);
	CDR = def_prim("cdr",1);
	CADR = def_prim("cadr",1);
	CDDR = def_prim("cddr",1);
	CONS = def_prim("cons",2);
	LIST = def_prim("list");
	EVAL = def_prim("eval",1);
	APPLY = def_prim("apply",2);
	READ = def_prim("read",0);
	WRITE = def_prim("write",1);
	NEWLINE = def_prim("newline",0);
	ADD = def_prim("+",2);
	SUB = def_prim("-",2);
	MUL = def_prim("*",2);
	DIV = def_prim("quotient",2);
	MOD = def_prim("remainder",2);
	LT = def_prim("<",2);
	GET = def_prim("get",2);
	PUT = def_prim("put",3);
	ATOMP = def_prim("atom?",1);
	PAIRP = def_prim("pair?",1);
	SYMBOLP = def_prim("symbol?",1);
	NUMBERP = def_prim("number?",1);
	SETCAR = def_prim("set-car!",2);
	SETCDR = def_prim("set-cdr!",2);
	NREV = def_prim("reverse!",1);
	GENSYM = def_prim("gensym",0);
	RANDOM = def_prim("random",1);
	ERROR = def_prim("error");
	DRIVER = string_to_symbol("top-level-driver");
}

BEGIN {
	for (; ; )
	{
		if (((DRIVER in value) && (value[DRIVER] != NIL)))
			apply(value[DRIVER]);
		else
		{
			expr = read();
			if ((expr == THE_EOF_OBJECT))
				break;
			protect(expr);
			print_expr(eval(expr));
			unprotect();
		}
	}
	if (profiling)
		for (proc in call_count)
		{
			printf ("%5d ",call_count[proc]);
			print_expr(proc);
		}
}

